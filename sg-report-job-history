#!/usr/bin/perl -w

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


use strict qw(vars);

use DBI;
use Osstest;
use IO::Handle;
use HTML::Entities;

use Osstest::Executive;

our (@blessings,@branches);
our $limit= 100;
our $htmlout;
our $flight;
our $job;

open DEBUG, ">/dev/null";

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--?$/;
    if (m/^--(job|flight)\=(.*)$/) {
        $$1= $2;
    } elsif (m/^--(limit)\=([1-9]\d*)$/) {
        $$1= $2;
    } elsif (restrictflight_arg($_)) {
	# Handled by Executive
    } elsif (m/^--html-dir=(.*)$/) {
        $htmlout= $1;
    } elsif (m/^--branches?=(.*)$/) {
        push @branches, split ',', $1;
    } elsif (m/^--blessings?=(.*)$/) {
        push @blessings, split ',', $1;
    } elsif (m/^--debug/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
        die "$_ ?";
    }
}

@ARGV==0 or die;

csreadconfig();
@blessings= qw(real) if !@blessings;

our @jobs;

sub findflight () {
    my $branches= $dbh_tests->selectcol_arrayref(<<END, {}, $flight);
        SELECT branch FROM flights WHERE flight=?
END
    die "$flight ? @$branches ?" if @$branches!=1;
    @branches= @$branches;

    my $selectq= db_prepare(<<END);
        SELECT job FROM jobs WHERE flight=? ORDER BY JOB
END
    $selectq->execute($flight);
    while (my ($j) = $selectq->fetchrow_array) { push @jobs, $j; }
}

if (defined($flight)) {
    die if defined $job;
    die if @branches;
    findflight();
} else {
    die unless defined $job;
    die unless @branches;
    push @jobs, $job;
}

our $revisionsq= db_prepare(<<END);
        SELECT * FROM runvars
         WHERE flight=? AND job=?
           AND name LIKE E'built\\_revision\\_\%'
END

sub add_revisions ($$$$) {
    my ($revmap, $flightnum, $j, $sfx) = @_;
    $revisionsq->execute($flightnum, $j);
    while (my $row= $revisionsq->fetchrow_hashref()) {
        my $n= $row->{name};
        $n =~ s/^built_revision_//;
        $revmap->{$n.$sfx}= $row->{val};
    }
}

our $buildsq= db_prepare(<<END);
        SELECT * FROM runvars
         WHERE flight=? AND job=?
           AND name LIKE E'\%buildjob'
END

sub processjobbranch ($$) {
    my ($j,$bra) = @_;

    print DEBUG "processjobbranch('$j',", ($bra ? "'$bra'" : 'undef'), ")\n";

    my %rev_grid_col;
    my @rev_grid_cols;
    my @test_rows;

    my $blessingscond= report_blessingscond(\@blessings);
    my $cond = "job = ? AND $blessingscond";
    my (@params) = ($j);
    if (defined $bra) {
        $cond .= " AND branch = ?";
        push @params, $bra;
    }
    my $offset= $limit-1;

    my $fromstuff= <<END;
          FROM jobs JOIN flights USING (flight)
         WHERE ($cond)
      ORDER BY flight DESC
END
    my $flightsq= db_prepare(<<END);
        SELECT * $fromstuff
         LIMIT $limit
END
    $flightsq->execute(@params);

    my $hostsq= db_prepare(<<END);
        SELECT DISTINCT name
	 FROM runvars
	 JOIN flights USING (flight)
	WHERE ($cond)
	  AND flight >= COALESCE(
             (
	      SELECT flight $fromstuff
	      LIMIT 1 OFFSET $offset
	     ), 0)
     ORDER BY name;
END
    $hostsq->execute(@params, @params); # sql text contains $cond twice
    my @hostvarcols;
    while (my ($hostvar) = $hostsq->fetchrow_array()) {
	next unless $hostvar =~ m/(^|_)host$/;
	push @hostvarcols, $hostvar;
    }

    my $hostq= db_prepare(<<END);
        SELECT val FROM runvars WHERE flight=? AND job=? AND name=?
END

    while (my $f= $flightsq->fetchrow_hashref()) {
        my $ri= report_run_getinfo($f);

	$ri->{Hosts} = [ ];
	foreach my $hostvar (@hostvarcols) {
	    $hostq->execute($f->{flight}, $f->{job}, $hostvar);
	    my ($host) = $hostq->fetchrow_array();
	    push @{ $ri->{Hosts} }, ($host // "-");
	}

        my %revisions;
        add_revisions(\%revisions, $f->{flight}, $f->{job}, '');
        
        $buildsq->execute($f->{flight}, $f->{job});
        while (my $bld= $buildsq->fetchrow_hashref()) {
            my $bn= $bld->{name};
            $bn =~ s/buildjob$//;
            my ($oflight,$ojob) = flight_otherjob($f->{flight}, $bld->{val});
            add_revisions(\%revisions, $oflight, $ojob, " ($bn)");
        }
        my @rev_cols;
        foreach my $revk (sort keys %revisions) {
            my $col= $rev_grid_col{$revk};
            if (!defined $col) {
                $col= @rev_grid_cols;
                push @rev_grid_cols, $revk;
                $rev_grid_col{$revk}= $col;
            }
            $rev_cols[$col]= $revisions{$revk};
        }
        $ri->{Revisions}= \@rev_cols;
        $ri->{Flight}= $f;

        push @test_rows, $ri;
    }

    my $osstestverq= db_prepare(<<END);
        SELECT DISTINCT harness
          FROM flights_harness_touched
         WHERE flight=?
END

    if (defined $htmlout) {
        my ($title,$html_file,$url);
	ensuredir "$htmlout/history";
	ensuredir "$htmlout/history/$j";
        if (defined $bra) {
            $title= "$j (branch $bra)";
            $html_file= "history/$j/$bra.html";
        } else {
            $title= "$j (all branches)";
            $html_file= "history/$j/ALL.html";
        }
        $html_file= "$htmlout/$html_file";
        open H, "> $html_file.new" or die "$html_file $!";
        $title= encode_entities($title);
        print H "<html><head><title>$title</title></head><body>\n";
        print H "<h1>$title</h1>\n";
        print H "<table rules=all>";
        print H "<tr><th>started</th><th>flight</th>",
	        "<th>branch</th><th>failure</th>\n";
        print H "<th>", (join ", ", @hostvarcols), "</th>\n";
        print H "<th>osstest</th>";
        foreach my $c (@rev_grid_cols) {
            print H "<th>".encode_entities($c)."</th>\n";
        }
        print H "</tr>\n";
        my $alternate= 0;
        my @last_revs;
        my @alt_revs;
        my $alt_hosts;
        foreach my $r (@test_rows) {
            my $altcolour= report_altcolour($alternate);
            print H "<tr $altcolour>";
	    my $started = $r->{Flight}{started};
	    print H "<td>";
	    print H show_abs_time $started if $started;
	    print H "</td>\n";
            my $flt= $r->{Flight}{flight};
            $url= "$c{ReportHtmlPubBaseUrl}/$flt";
            print H "<td><a href=\"$url\">$flt</a></td>\n";
            print H "<td>".encode_entities($r->{Flight}{branch})."</td>\n";
            $url= "$c{ReportHtmlPubBaseUrl}/$flt/".encode_entities($j).
		"/info.html";
            print H "<td $r->{ColourAttr}><a href=\"$url\">".
                $r->{Content}."</a></td>\n";
            my $lastrev;
            my $hosts = join ", ", map { $_ // "-" } @{ $r->{Hosts} };
            my $hosts_colour = report_altchangecolour(\$alt_hosts, $hosts);
            print H "<td $hosts_colour>".encode_entities($hosts)."</td>\n";
            $osstestverq->execute($r->{Flight}{flight});
            print H
                "<td>",
                (join ' ',
                 map {
                    $_ = $_->{harness};
                    s/^([0-9a-f]{12})[0-9a-f]+\b/$1/;
                    "<kbd>".encode_entities($_)."</kbd>";
                 }
                 @{ $osstestverq->fetchall_arrayref({}) }),
                "</td>\n";
            foreach my $i (0..$#rev_grid_cols) {
                my $v= $r->{Revisions}[$i];
		my $rev_colour = report_altchangecolour(\$alt_revs[$i], $v);
                print H "<td $rev_colour>";
                if (defined $v) {
                    my $vp= $v;
                    if (defined $lastrev && $v eq $lastrev) {
                        $vp= '<-';
                    } else {
                        $vp =~ s/^((?:\d+\:)?[0-9a-f]{12})([0-9a-f].*)$/$1/;
                    }
                    print H "<kbd>".encode_entities($vp)."</kbd>";
                }
                $lastrev= $v;
                $last_revs[$i]= $v;
                print H "</td>";
            }
            print H "</tr>\n";
            $alternate ^= 1;
        }
        print H "</table></body></html>\n";
        H->error and die $!;
        close H or die $!;
        rename "$html_file.new", $html_file or die "$html_file $!";
        #print "wrote $html_file\n";
    }
}

sub processjob ($) {
    my ($j) = @_;
    processjobbranch($j,undef);
    processjobbranch($j,$_) foreach @branches;
}

db_begin_work($dbh_tests, [qw(flights)]);
foreach my $j (@jobs) { processjob($j); }
