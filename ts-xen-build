#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict qw(vars);
use DBI;
use Osstest;
use File::Path;
use POSIX;
use Osstest::TestSupport;
use Osstest::BuildSupport;

tsreadconfig();
selectbuildhost(\@ARGV);
# remaining arguments are passed as targets to "make"
builddirsprops();

my $enable_xsm = $r{enable_xsm} =~ m/true/ ? 1 : 0;
    
sub checkout () {
    prepbuilddirs();

    build_clone($ho, 'xen', $builddir, 'xen');

    my $debug_build = $r{xen_build_debug} || 'y';
    my $build_xsm = $enable_xsm ? 'y' : 'n';

    # Do not set this unless you know what you are doing. This arm
    # option makes the build specific to a particular type of
    # hardware.  This is only really useful in the standalone
    # configuration and even then you are still responsible for
    # ensuring that this build only gets run on hardware which
    # supports the given early printk mechanism.
    my $earlyprintk = get_host_property($ho, 'EarlyPrintk', undef);

    target_cmd_build($ho, 100, $builddir, <<END.
        cd $builddir/xen
	>.config
	echo >>.config debug=$debug_build
	echo >>.config GIT_HTTP=y
	echo >>.config LIBLEAFDIR_x86_64=lib
	echo >>.config QEMU_REMOTE='$r{tree_qemu}'
	echo >>.config KERNELS=''
END
               (nonempty($r{enable_xsm}) ? <<END : '').
	echo >>.config XSM_ENABLE='${build_xsm}'
END
               (nonempty($r{revision_qemu}) ? <<END : '').
	echo >>.config QEMU_TAG='$r{revision_qemu}'
END
               (nonempty($r{tree_qemuu}) ? <<END : '').
	echo >>.config QEMU_UPSTREAM_URL='$r{tree_qemuu}'
END
               (nonempty($r{revision_qemuu}) ? <<END : '').
	echo >>.config QEMU_UPSTREAM_REVISION='$r{revision_qemuu}'
END
               (nonempty($r{tree_seabios}) ? <<END : '').
	echo >>.config SEABIOS_UPSTREAM_URL='$r{tree_seabios}'
END
               (nonempty($r{revision_seabios}) ? <<END : '').
	echo >>.config SEABIOS_UPSTREAM_TAG='$r{revision_seabios}'
END
               (nonempty($r{tree_ovmf}) ? <<END : '').
	echo >>.config OVMF_UPSTREAM_URL='$r{tree_ovmf}'
END
               (nonempty($r{revision_ovmf}) ? <<END : '').
	echo >>.config OVMF_UPSTREAM_REVISION='$r{revision_ovmf}'
END
               (nonempty($earlyprintk) ? <<END : '').
	echo >>.config CONFIG_EARLY_PRINTK=$earlyprintk
END
               ($ho->{Suite} =~ m/squeeze|wheezy/ ? <<END : '') #Debian #693721
	echo >>.config PYTHON_PREFIX_ARG=
END
               );
}

sub buildcmd_stamped_logged ($$$$$) {
    my ($timeout, $stampname, $prefix, $cmd, $suffix) = @_;
    target_cmd_build($ho, $timeout, $builddir, <<END);
        cd xen
        $prefix
        ( $cmd 2>&1 &&             touch ../$stampname-ok-stamp
        ) |tee ../$stampname-log
        test -f ../$stampname-ok-stamp
        $suffix
        echo ok.
END
#/;
}

sub build () {
    my $xend_opt= $r{enable_xend} =~ m/true/ ? "--enable-xend" : "--disable-xend";
    my $ovmf_opt= $r{enable_ovmf} =~ m/true/ ? "--enable-ovmf" : "--disable-ovmf";

    my $configure_prefix = $r{cmdprefix_configure} // '';
    my $make_prefix =      $r{cmdprefix_make}      // '';

    buildcmd_stamped_logged(600, 'configure', <<END,<<END,<<END);
            if test -f configure; then
                if grep -q -- $xend_opt tools/configure ; then
		    xend=$xend_opt
                fi
                if grep -q -- $ovmf_opt tools/configure ; then
                    ovmf=$ovmf_opt
                fi
END
               $configure_prefix ./configure --sysconfdir=/etc \$xend \$ovmf
END
            fi
END
#/;
    buildcmd_stamped_logged(9000, 'build', '',<<END,'');
            $make_prefix make $makeflags @ARGV
END

    if ($enable_xsm) {
	my $xen_version = target_cmd_output($ho, <<END, 30);
	    cd $builddir/xen
	    $make_prefix make xenversion
END
	store_runvar("flaskpolicy", "xenpolicy-" . $xen_version);
    }
}

sub collectversions () {
    my $tools="$builddir/xen/tools";
    store_revision($ho, 'qemu', "$tools/ioemu-dir", 1);
    store_revision($ho, 'qemu', "$tools/qemu-xen-traditional-dir", 1);
    store_revision($ho, 'qemuu', "$tools/qemu-xen-dir", 1);
    store_revision($ho, 'seabios', "$tools/firmware/seabios-dir", 1);
    store_revision($ho, 'ovmf', "$tools/firmware/ovmf-dir", 1);
}

sub divide () {
    target_cmd_build($ho, 100, $builddir, <<END);
        cd xen/dist
        mkdir xeninstall
	for f in *install; do
	    mkdir -p \$f/lib
	done
        if test -d install/boot; then
            if test -f install/boot/xen.gz || test -f install/boot/xen; then
                mkdir xeninstall/boot
                mv install/boot/xen* xeninstall/boot/.
            fi
        fi
END
}

sub stash () {
    foreach my $part ('', 'xen') {
        built_stash($ho, $builddir,
                    "xen/dist/${part}install",
                    "${part}dist");
    }
    built_stash_file($ho, $builddir, "xen-syms", "xen/xen/xen-syms", 1);
    built_stash_file($ho, $builddir, "xen-config", "xen/.config", 1);
    built_stash_file($ho, $builddir, "seabios-config",
		     "xen/tools/firmware/seabios-dir-remote/.config", 1);
    built_compress_stashed("xen-syms");
}

sub checkversions () {
    my $chk= $dbh_tests->prepare(<<END);
        SELECT reqd.name, reqd.val, built.val
          FROM runvars reqd, runvars built
         WHERE reqd.flight=? and reqd.job=?
           AND built.flight=? and built.job=?
           AND built.name = 'built_' || reqd.name
END
    $chk->execute($flight,$job,$flight,$job);
    my $mismatches= 0;
    while (my $row= $chk->fetchrow_arrayref()) {
        my ($tree, $reqd, $built) = @$row;
        next unless defined $reqd && defined $built;
        $reqd =~ s/^.*://;
        $built =~ s/^.*://;
        next if substr($reqd,0,length($built))
             eq substr($built,0,length($reqd));
        print STDERR "version mismatch! $tree requested=$reqd built=$built\n";
        $mismatches++;
    }
    broken("version mismatches ($mismatches)") if $mismatches;
    $chk->finish();
}

our @probs;

sub trapping ($) {
    my ($sub) = @_;
    my $tok= eval { $sub->(); 1; };
    if (!$tok) { push @probs, $@; print STDERR "failure (trapped): $@\n"; }
}

checkout();

trapping(\&build);
trapping(\&collectversions);

die "*** something failed:\n\n".(join "\n\n",@probs)."\n** something failed"
    if @probs;

divide();
stash();
checkversions();
