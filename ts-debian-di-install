#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Configured via the following runvars (which are mandatory unless
# otherwise noted):
#
# - <gident>_arch:
#      Debian arch to install.
# - <gident>_method:
#      Install method, one of "netboot" or "netinst".
# - <gident>_bootloader:
#      The PV bootloader to use when booting the guest. One of
#      "pvgrub" or "pygrub". Default is "pygrub".
#
# For method="netboot":
#
#  - <gident>_netboot_kernel:
#       URL of the kernel to boot.
#  - <gident>_netboot_ramdisk:
#       URL of the ramdisk to boot.
#
#    If neither kernel nor ramdisk are specified then the current
#    TftpDiVersion of d-i will be used, and the runvars will be set to
#    the file path used.
#
# For method="netinst"
#
#  - <gident>_netinst_baseurl:
#       Base URL of directory containing the netinst jigdo images.
#  - <gident>_netinst_filere:
#        Regular expression to match actual file within baseurl to use
#        (without .jigdo suffix)
#  - <gident>_netinst_kernel:
#       Path to kernel within the netinst image.
#  - <gident>_netinst_ramdisk
#       Path to ramdisk within the netinst image.

use strict qw(vars);
use DBI;
use Osstest;
use Osstest::Debian;
use Osstest::TestSupport;

tsreadconfig();

our ($whhost,$gn) = @ARGV;
$whhost ||= 'host';
$gn ||= 'debian';

our $ho= selecthost($whhost);

our $ram_mb=    512;
our $disk_mb= 10000;

our $guesthost= "$gn.guest.osstest";
our $gho;

sub prep () {
    target_install_packages_norec($ho, qw(lvm2));

    $gho= prepareguest($ho, $gn, $guesthost, 22,
                       $disk_mb, 40);

    prepareguest_part_lvmdisk($ho, $gho, $disk_mb);

    target_cmd_root($ho, "umount $gho->{Lvdev} ||:");
}

sub setup_netinst($$)
{
    my ($didir, $arch) = @_;

    target_install_packages($ho, qw(jigdo-file));

    my $baseurl = $r{ "$gho->{Guest}_netinst_baseurl" };
    my $filere = $r{ "$gho->{Guest}_netinst_filere" };
    my $kernel = $r{ "$gho->{Guest}_netinst_kernel" };
    my $ramdisk = $r{ "$gho->{Guest}_netinst_ramdisk" };

    die "params" unless $baseurl && $filere && $kernel && $ramdisk;

    my $filebase;

    # Use the MD5SUMs file as an index
    logm("Fetch index from $baseurl/MD5SUMS");
    my $idx = target_cmd_output_root($ho, "wget --quiet -O - $baseurl/MD5SUMS");
    foreach (split /\n/, $idx) {
	m/^[0-9a-f]{32}  ($filere)\.iso$/ or next;
	$filebase = $1;
	last;
    }

    die unless $filebase;

    logm("Downloading $baseurl/$filebase.jigdo");
    my $netinst_jigdo = "$baseurl/$filebase.jigdo";
    # Jigdo uses wget internally, and so obeys $http_proxy. This seems
    # simpler than the advice at
    # https://www.debian.org/CD/jigdo-cd/#faq which is to edit
    # ~/.jigdo-lite and change the wgetOpts setting.
    my $useproxy = $c{DebianMirrorProxy} // $c{HttpProxy} // '';
    my $cmd = '';
    $cmd .= <<END if $useproxy;
        export http_proxy=$useproxy
END
    $cmd .= <<END;
        cd $didir && jigdo-lite --noask $netinst_jigdo
END
    # Jigdo seems to use /etc/apt/sources.list or something, so this
    # just works using the already configured mirror without
    # additional configuration, which is good because there doesn't
    # seem to be any support for such things, at least in Squeeze.
    target_cmd_root($ho, $cmd, 3600);
    store_runvar("$gho->{Guest}_netinst_jigdo", $netinst_jigdo);

    return (<<END, "\"file:$didir/$filebase.iso,xvdd:cdrom,r\",");
bootloader = "pygrub"
bootloader_args = ["--kernel=$kernel",
                   "--ramdisk=$ramdisk"]
END
}

sub setup_netboot($$$)
{
    my ($didir, $arch, $suite) = @_;

    my ($kernel,$ramdisk);

    if ( $r{ "$gho->{Guest}_netboot_kernel" } &&
	 $r{ "$gho->{Guest}_netboot_ramdisk" } ) {
	target_fetchurl($ho, $r{ "$gho->{Guest}_netboot_kernel" },
			     "$didir/kernel_${suite}_${arch}");
	target_fetchurl($ho, $r{ "$gho->{Guest}_netboot_ramdisk" },
			     "$didir/ramdisk_${suite}_${arch}");
    } else {
	# Both or neither must be specified
	die if $r{ "$gho->{Guest}_netboot_kernel" }
	||     $r{ "$gho->{Guest}_netboot_ramdisk" };

	my $di_path = $c{TftpPath}.'/'.$ho->{Tftp}{DiBase}.'/'.${arch}.'/'.$c{TftpDiVersion}.'-'.$ho->{Suite};

        my $suffix = '';
        $suffix .= "-xen" if ${arch} =~ m/amd64|i386/;
	$kernel = "$di_path/vmlinuz$suffix";
	$ramdisk = "$di_path/initrd.gz$suffix";

	target_putfile_root($ho, 60, $kernel, "$didir/kernel_${suite}_${arch}");
	target_putfile_root($ho, 60, $ramdisk, "$didir/ramdisk_${suite}_${arch}");

	store_runvar("$gho->{Guest}_netboot_kernel", $kernel);
	store_runvar("$gho->{Guest}_netboot_ramdisk", $ramdisk);
    }

    return <<END;
kernel      = "$didir/kernel_${suite}_${arch}"
ramdisk     = "$didir/ramdisk_${suite}_${arch}"
END
}

sub ginstall () {
    my $arch= $r{"$gho->{Guest}_arch"};
    my $method= $r{"$gho->{Guest}_method"};

    my $tmpdir= "/root/$flight-$job-di";
    my $bl= $r{"$gho->{Guest}_bootloader"};

    target_cmd_root($ho, <<END);
rm -rf $tmpdir
mkdir $tmpdir
END

    my ($method_cfg, $ps_url, $extra_disk);

    if ( $method eq "netboot" )
    {
	my $suite= $r{"$gho->{Guest}_suite"};
	logm("$method $suite/$arch");

	$method_cfg = setup_netboot($tmpdir, $arch, $suite);

	$ps_url = preseed_create_guest($gho, $arch, '',
				       Suite=>$suite,
				       PvMenuLst=>($bl eq "pvgrub"));

	$extra_disk = "";
    }
    elsif ($method eq "netinst" )
    {
	logm("$method $arch");

	($method_cfg,$extra_disk) = setup_netinst($tmpdir, $arch);

	$ps_url = preseed_create_guest($gho, $arch, '', CDROM=>1);
    }
    else
    {
	die "$method";
    }

    my @cmdline = ();
    push @cmdline, "debian-installer/exit/always_halt=true";
    push @cmdline, "domain=$c{TestHostDomain}";
    push @cmdline, "console=hvc0";
    push @cmdline, di_installcmdline_core($gho, $ps_url);
    push @cmdline, "--";
    # See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=762007 for
    # why this is repeated.
    push @cmdline, "console=hvc0";

    my $cmdline = join(" ", @cmdline);

    my %install_xopts = (
	OnPowerOff => "preserve"
    );

    my $root_disk = "'phy:$gho->{Lvdev},xvda,w'";

    prepareguest_part_xencfg($ho, $gho, $ram_mb, \%install_xopts, <<END);
$method_cfg
extra       = "$cmdline"
#
disk        = [
            $extra_disk $root_disk
            ]
END

    guest_create($gho);

    guest_checkrunning($ho, $gho) or die "$gho->{Name} not running";

    guest_await_shutdown($ho,$gho,3600);
    guest_destroy($gho);

    my $xenarch = $arch_debian2xen{$arch};
    my $pvgrub = "/usr/local/lib/xen/boot/pv-grub-$xenarch.gz";
    my $blcfg = $bl eq "pvgrub" ? <<END : <<END;
kernel = "$pvgrub"
extra = "(hd0,0)/boot/grub/menu.lst"
END
bootloader = "pygrub"
END

    prepareguest_part_xencfg($ho, $gho, $ram_mb, {}, <<END);
$blcfg
#
disk        = [
            $root_disk
            ]
END
    return;
}

prep();
ginstall();
