#!/usr/bin/perl -w

use strict qw(vars);
use DBI;
use Osstest;
use File::Path;
use POSIX;

my $checkmode= 0;

readconfig();
opendb_state();

our @hos;

if (@ARGV and $ARGV[0] eq '--check') {
    $checkmode= 1;
    shift @ARGV;

    logm("checking builds are done...");
    if (!@ARGV) {
	foreach my $k (keys %r) {
	    next unless $k =~ m/^(?:\w.*_)?host$/;
	    push @ARGV, $k;
	}
    }
} else {
    if (!@ARGV) {
	push @ARGV, 'host';
    }
}

foreach my $k (@ARGV) {
    push @hos, selecthost($r{$k});
}

our $ho;

my %distpath;

sub packages () {
    target_install_packages($ho,
                            qw(bridge-utils vncsnapshot
                               libsdl1.2debian));
    if ($r{arch} eq 'i386') {
	target_install_packages($ho, 'libc6-xen');
    }
}

sub extract_one ($$$) {
    my ($part, $path, $job) = @_;
    $distpath{$part}= get_stashed($path, $job);
    return if $checkmode;
    my $local= $path;  $local =~ s/path_//;
    my $distcopy= "/root/extract_$local.tar.gz";
    target_putfile_root($ho, 300, $distpath{$part}, $distcopy);
    target_cmd_root($ho, "cd / && tar zxf $distcopy", 300);
}

sub extract () {
    foreach my $part ('', 'kern', 'xen') {
        extract_one($part, "path_${part}dist", $r{"${part}buildjob"});
    }
}

sub adjustconfig () {
    target_editfile_root($ho, "/etc/xen/xend-config.sxp",
			 "xend-config.sxp", sub {
	my (@domains) = (qw(localhost localhost.localdomain),
			 ".".$c{Domain}, ".".$c{TestHostDomain});
	logm("relocation domains: @domains");
	foreach (@domains) {
	    s/\./\\$&/g;
	    s/^/^/g;
	    s/$/\$/g;
	    s/^\^(\\\.)/.\*$1/;
	}
	$_= join ' ', @domains;
	s/[\'\\]/\\$&/g;
	my $extra= "(xend-relocation-hosts-allow '$_')";
	logm("relocation setting: $extra");
	$extra .= "\n";
        while (<EI>) {
	    s/^\s*\(xend-relocation-hosts-allow/#$&/;
	    print EO or die $!;
	    if (m/^\#\(xend-relocation-hosts-allow/) {
		print EO $extra or die $!;
		$extra= '';
	    }
	}
	print EO $extra or die $!;
    });

    my $trace_config_file=
        target_file_exists($ho, '/etc/sysconfig/xencommons')
        ? '/etc/sysconfig/xencommons'
        : '/etc/sysconfig/xend';

    target_editfile_root($ho, $trace_config_file, sub {
        my $prnow;
        $prnow= sub {
            print EO "XENCONSOLED_TRACE=guest\n" or die $!;
            $prnow= sub { };
        };
        while (<EI>) {
            print EO or die $! unless m/^XENCONSOLED_TRACE/;
            $prnow->() if m/^#XENCONSOLED_TRACE/;
        }
        print EO "\n" or die $!;
        $prnow->();
    });

    target_cmd_root($ho, 'mkdir -p /var/log/xen/console');
}

sub setupboot () {
    my $rmenu= "/boot/grub/menu.lst";

    target_kernkind_check($ho);
    target_kernkind_console_inittab($ho,$ho,"/");

    my $xenhopt= "com1=$c{Baud},8n1 console=com1,vga gdb=com1 conswitch=x";
    if (toolstack()->{Dom0MemFixed}) {
        $xenhopt .= " dom0_mem=512M";
    }

    my $console= $r{console};
    if (defined $console && length $console) {
        $console= "console=$console";
    } else {
        $console= "xencons=ttyS console=ttyS0,$c{Baud}n8";
    }

    target_editfile_root($ho, $rmenu, sub {
        while (<EI>) {
            if (m/^## ## Start Default/ ..
                m/^## ## End Default/) {
                s/^# xenhopt=.*/# xenhopt= $xenhopt/;
                s/^# xenkopt=.*/# xenkopt= $console/;
            }
            print EO or die $!;
        }
    });

    target_cmd_root($ho, "update-grub");

    my $lmenu= "$stash/$ho->{Name}--menu.lst.out";
    target_getfile($ho, 60, $rmenu, $lmenu);
    my $f= new IO::File $lmenu, 'r' or die "$lmenu $?";
    my $def;
    while (<$f>) {
        last if m/^\s*title\b/;
        next unless m/^\s*default\b/;
        die "$_ ?" unless m/^\s*default\s+(\d+)\s*$/;
        $def= $1;
        last;
    }
    my $ix= -1;
    die unless defined $def;
    logm("boot check: grub default is option $def");
    my $kern;
    while (<$f>) {
        s/^\s*//; s/\s+$//;
        if (m/^title\b/) {
            $ix++;
            if ($ix==$def) {
                logm("boot check: title $'");
            }
            next;
        }
        next unless $ix==$def;
        if (m/^kernel\b/) {
            die "$_ ?" unless
                m,^kernel\s+/(?:boot/)?(xen\-[-+.0-9a-z]+\.gz)(?:\s.*)?$,;
            logm("boot check: xen: $1");
        }
        if (m/^module\b/) {
            die "$_ ?" unless m,^module\s+/((?:boot/)?\S+)(?:\s.*)?$,;
            $kern= $1;
            logm("boot check: kernel: $kern");
            last;
        }
    }
    die "$def $ix" unless defined $kern;
    system "tar zvtf $distpath{kern} boot/$kern"; $? and die $?;

    my $kernver= $kern;
    $kernver =~ s,^/?(?:boot/)?(?:vmlinu[xz]-)?,, or die "$kernver ?";

    my $kernpath= $kern;
    $kernpath =~ s,^(?:boot/)?,/boot/,;

    target_cmd_root($ho,
                    "update-initramfs -k $kernver -c ||".
                    " update-initramfs -k $kernver -u",
                    200);
    target_cmd_root($ho, "update-grub");
    store_runvar('xen_kernel_path',$kernpath);
    store_runvar('xen_kernel_ver',$kernver);

    logm("ready to boot Xen");
}

our $initscripts_nobridge;

sub setupinitd () {
    my $ts= toolstack();
    my $have_xencommons=
        !!target_cmd_output_root($ho,
                        "if test -f /etc/init.d/xencommons; then echo y; fi");
    $initscripts_nobridge= !defined($ts->{OldDaemonInitd}) || $have_xencommons;
    logm("init.d scripts ".
         ($initscripts_nobridge
          ? 'do not mess with bridge, doing it in interfaces(5)'
          : '_do_ mess with bridge, letting them handle it'));
    my $cmd= '';
    my $updatercd= sub {
        my ($script,$start) = @_;
        $cmd .= "\n    update-rc.d $script start $start 2 .";
    };
    if ($initscripts_nobridge) {
        my $script= $have_xencommons ? 'xencommons' : 'xenlightdaemons';
        $updatercd->($script,92);
        my $pri= 93;
        foreach my $d (@{ $ts->{NewDaemons} }) {
            $updatercd->("$d",$pri);
            $pri++;
        }
    } else {
        my $initd= $ts->{OldDaemonInitd};
        $updatercd->($initd,93) if defined $initd;
        $updatercd->('xenbridge',38) if $ts->{OldSeparateBridgeInitd};
    }
    target_cmd_root($ho, $cmd);
}

sub nodhcp () {
    my ($iface,$bridgex);
    if ($initscripts_nobridge) {
        $iface= 'xenbr0';
        $bridgex= "bridge_ports eth0";
    } else {
        $iface= 'eth0';
        $bridgex= '';
    }
logm("iface $iface >$initscripts_nobridge<");
    target_editfile_root($ho, "/etc/network/interfaces",
                         "etc-network-interfaces", sub {
        my $suppress= 0;
        while (<EI>) {
            $suppress= 0 unless m/^\s+/;
            s/^ \s* allow-hotplug \s+ (?: eth0 | xenbr0 ) \s* $
                /auto $iface\n/x;
            if (m/^\s* iface \s+ (?: eth0 | xenbr0 ) \s+ inet \s /x) {
                $suppress= 1;
                print EO <<END;
iface $iface inet static
    address $ho->{Ip}
    netmask $c{NetNetmask}
    gateway $c{NetGateway}
    $bridgex
END
            }
            print EO or die $!
                unless $suppress;
        }
    });
}    

if ($checkmode) {
    foreach $ho (@hos) {
	extract();
    }
} else {
    die if @hos > 1;
    $ho= $hos[0];
    
    packages();
    extract();
    adjustconfig();
    setupboot();
    setupinitd();
    nodhcp();
}
