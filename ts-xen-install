#!/usr/bin/perl -w

use strict qw(vars);
use DBI;
use Osstest;
use File::Path;
use POSIX;

my $checkmode= 0;

readconfig();
opendb_state();

our @hos;

if (@ARGV and $ARGV[0] eq '--check') {
    $checkmode= 1;
    shift @ARGV;
    logm("checking builds are done...");
} else {
    if (!@ARGV) {
	push @ARGV, 'host';
    }
    foreach my $k (@ARGV) {
        push @hos, selecthost($k);
    }
}

our $ho;

my %distpath;

sub packages () {
    target_install_packages($ho,
                            qw(bridge-utils vncsnapshot
                               libsdl1.2debian));
    if ($r{arch} eq 'i386') {
	target_install_packages($ho, 'libc6-xen');
    }
}

sub extract_one ($$$) {
    my ($part, $path, $job) = @_;
    $distpath{$part}= get_stashed($path, $job);
    return if $checkmode;
    my $local= $path;  $local =~ s/path_//;
    my $distcopy= "/root/extract_$local.tar.gz";
    target_putfile_root($ho, 300, $distpath{$part}, $distcopy);
    target_cmd_root($ho, "cd / && tar zxf $distcopy", 300);
}

sub extract () {
    foreach my $part ('', 'kern', 'xen') {
        extract_one($part, "path_${part}dist", $r{"${part}buildjob"});
    }
}

sub adjustconfig () {
    target_editfile_root($ho, "/etc/xen/xend-config.sxp",
			 "xend-config.sxp", sub {
	my (@domains) = (qw(localhost localhost.localdomain),
			 ".".$c{Domain}, ".".$c{TestHostDomain});
	logm("relocation domains: @domains");
	foreach (@domains) {
	    s/\./\\$&/g;
	    s/^/^/g;
	    s/$/\$/g;
	    s/^\^(\\\.)/.\*$1/;
	}
	$_= join ' ', @domains;
	s/[\'\\]/\\$&/g;
	my $extra= "(xend-relocation-hosts-allow '$_')";
	logm("relocation setting: $extra");
	$extra .= "\n";
        while (<EI>) {
	    s/^\s*\(xend-relocation-hosts-allow/#$&/;
	    print EO or die $!;
	    if (m/^\#\(xend-relocation-hosts-allow/) {
		print EO $extra or die $!;
		$extra= '';
	    }
	}
	print EO $extra or die $!;
    });

    my $trace_config_file;
    foreach my $try (qw(/etc/default/xencommons
                        /etc/sysconfig/xencommons
                        /etc/default/xend
                        /etc/sysconfig/xend)) {
        next unless target_file_exists($ho, $try);
        $trace_config_file= $try;
        last;
    }
    die unless defined $trace_config_file;

    target_editfile_root($ho, $trace_config_file, sub {
        my $prnow;
        $prnow= sub {
            print EO "XENCONSOLED_TRACE=guest\n" or die $!;
            $prnow= sub { };
        };
        while (<EI>) {
            print EO or die $! unless m/^XENCONSOLED_TRACE/;
            $prnow->() if m/^#XENCONSOLED_TRACE/;
        }
        print EO "\n" or die $!;
        $prnow->();
    });

    target_cmd_root($ho, 'mkdir -p /var/log/xen/console');
}

sub setupboot () {
    target_kernkind_check($ho);
    target_kernkind_console_inittab($ho,$ho,"/");

    my $xenhopt= "com1=$c{Baud},8n1 console=com1,vga gdb=com1 conswitch=x".
        " watchdog";
    if (toolstack()->{Dom0MemFixed}) {
        $xenhopt .= " dom0_mem=512M";
    }
    my $append= $r{xen_boot_append};
    $xenhopt .= " $append" if defined $append;

    my $console= $r{console};
    if (defined $console && length $console) {
        $console= "console=$console";
    } else {
        $console= "xencons=ttyS console=ttyS0,$c{Baud}n8";
    }

    my $bootloader;
    if ($c{Suite} eq 'lenny') {
        $bootloader= setupboot_grub1($ho, $xenhopt, $console);
    } else {
        $bootloader= setupboot_grub2($ho, $xenhopt, $console);
    }

    target_cmd_root($ho, "update-grub");

    my $kern= $bootloader->{GetBootKern}();
    logm("dom0 kernel is $kern");

    system "tar zvtf $distpath{kern} boot/$kern";
    $? and die "$distpath{kern} boot/$kern $?";

    my $kernver= $kern;
    $kernver =~ s,^/?(?:boot/)?(?:vmlinu[xz]-)?,, or die "$kernver ?";
    my $kernpath= $kern;
    $kernpath =~ s,^(?:boot/)?,/boot/,;

    target_cmd_root($ho,
                    "update-initramfs -k $kernver -c ||".
                    " update-initramfs -k $kernver -u",
                    200);

    $bootloader->{PreFinalUpdate}();

    target_cmd_root($ho, "update-grub");

    store_runvar('xen_kernel_path',$kernpath);
    store_runvar('xen_kernel_ver',$kernver);

    logm("ready to boot Xen");
}

sub bl_getmenu_open ($$) {
    my ($rmenu, $lmenu) = @_;
    target_getfile($ho, 60, $rmenu, $lmenu);
    my $f= new IO::File $lmenu, 'r' or die "$lmenu $?";
    return $f;
}

sub setupboot_grub1 ($$$) {
    my ($ho,$xenhopt,$xenkopt) = @_;
    my $bl= { };

    my $rmenu= "/boot/grub/menu.lst";
    my $lmenu= "$stash/$ho->{Name}--menu.lst.out";

    target_editfile_root($ho, $rmenu, sub {
        while (<EI>) {
            if (m/^## ## Start Default/ ..
                m/^## ## End Default/) {
                s/^# xenhopt=.*/# xenhopt= $xenhopt/;
                s/^# xenkopt=.*/# xenkopt= $xenkopt/;
            }
            print EO or die $!;
        }
    });

    $bl->{GetBootKern}= sub {
        my $f= bl_getmenu_open($rmenu, $lmenu);

        my $def;
        while (<$f>) {
            last if m/^\s*title\b/;
            next unless m/^\s*default\b/;
            die "$_ ?" unless m/^\s*default\s+(\d+)\s*$/;
            $def= $1;
            last;
        }
        my $ix= -1;
        die unless defined $def;
        logm("boot check: grub default is option $def");

        my $kern;
        while (<$f>) {
            s/^\s*//; s/\s+$//;
            if (m/^title\b/) {
                $ix++;
                if ($ix==$def) {
                    logm("boot check: title $'");
                }
                next;
            }
            next unless $ix==$def;
            if (m/^kernel\b/) {
                die "$_ ?" unless
                    m,^kernel\s+/(?:boot/)?(xen\-[-+.0-9a-z]+\.gz)(?:\s.*)?$,;
                logm("boot check: xen: $1");
            }
            if (m/^module\b/) {
                die "$_ ?" unless m,^module\s+/((?:boot/)?\S+)(?:\s.*)?$,;
                $kern= $1;
                logm("boot check: kernel: $kern");
                last;
            }
        }
        die "$def $ix" unless defined $kern;
        return $kern;
    };


    $bl->{PreFinalUpdate}= sub { };

    return $bl;
}

sub setupboot_grub2 ($$$) {
    my ($ho,$xenhopt,$xenkopt) = @_;
    my $bl= { };

    my $rmenu= '/boot/grub/grub.cfg';
 
    my $parsemenu= sub {
        my $f= bl_getmenu_open($rmenu, "$stash/$ho->{Name}--grub.cfg.1");
    
        my $count= 0;
        my $entry;
        while (<$f>) {
            next if m/^\s*\#/ || !m/\S/;
            if (m/^\s*\}\s*$/) {
                die unless $entry;
                my (@missing) =
                    grep { !defined $entry->{$_} } qw(Title Hv Kern);
                last if !@missing;
                logm("(skipping entry at $entry->{StartLine}; no @missing)");
                $entry= undef;
                next;
            }
            if (m/^function.*\{/) {
                $entry= { StartLine => $. };
            }
            if (m/^menuentry\s+[\'\"](.*)[\'\"].*\{\s*$/) {
                die $entry->{StartLine} if $entry;
                $entry= { Title => $1, StartLine => $., Number => $count };
                $count++;
            }
            if (m/^\s*multiboot\s*\/(xen\-[0-9][-+.0-9a-z]*\S+)/) {
                die unless $entry;
                $entry->{Hv}= $1;
            }
            if (m/^\s*module\s*\/(vmlinu[xz]-\S+)/) {
                die unless $entry;
                $entry->{Kern}= $1;
            }
            if (m/^\s*module\s*\/(initrd\S+)/) {
                $entry->{Initrd}= $1;
            }
        }
        die 'grub 2 bootloader entry not found' unless $entry;

        die unless $entry->{Title};
        die unless $entry->{Hv};
        die unless $entry->{Kern};

        logm("boot check: grub2, found $entry->{Title}");

        return $entry;
    };

    $bl->{GetBootKern}= sub { return $parsemenu->()->{Kern}; };

    $bl->{PreFinalUpdate}= sub {
        my $entry= $parsemenu->();
        
        target_editfile_root($ho, '/etc/default/grub', sub {
            my %k;
            while (<EI>) {
                if (m/^\s*([A-Z_]+)\s*\=\s*(.*?)\s*$/) {
                    my ($k,$v) = ($1,$2);
                    $v =~ s/^\s*([\'\"])(.*)\1\s*$/$2/;
                    $k{$k}= $v;
                }
                next if m/^GRUB_CMDLINE_(?:XEN|LINUX).*\=|^GRUB_DEFAULT.*\=/;
                print EO;
            }
            print EO <<END or die $!;

GRUB_DEFAULT=$entry->{Number}
GRUB_CMDLINE_XEN="$xenhopt"

END
            foreach my $k (qw(GRUB_CMDLINE_LINUX GRUB_CMDLINE_LINUX_DEFAULT)) {
                my $v= $k{$k};
                $v =~ s/\bquiet\b//;
                $v =~ s/\b(?:console|xencons)=[0-9A-Za-z,]+//;
                $v .= " $xenkopt" if $k eq 'GRUB_CMDLINE_LINUX';
                print EO "$k=\"$v\"\n" or die $!;
            }
        });
    };

    return $bl;
}

our $initscripts_nobridge;

sub setupinitd () {
    my $ts= toolstack();
    my $xencommons= '/etc/init.d/xencommons';
    my $have_xencommons=
        !!target_cmd_output_root($ho, <<END);
 if test -f $xencommons && ! grep 'FOR USE WITH LIBXL' $xencommons >/dev/null
 then
   echo y
 fi
END
    $initscripts_nobridge= !defined($ts->{OldDaemonInitd}) || $have_xencommons;
    logm("init.d scripts ".
         ($initscripts_nobridge
          ? 'do not mess with bridge, doing it in interfaces(5)'
          : '_do_ mess with bridge, letting them handle it'));
    my $cmd= '';
    my $updatercd= sub {
        my ($script,$start) = @_;
        $cmd .= "\n    update-rc.d $script start $start 2 .";
    };
    if ($initscripts_nobridge) {
        my $script= $have_xencommons ? 'xencommons' : 'xenlightdaemons';
        $updatercd->($script,92);
        my $pri= 93;
        foreach my $d (@{ $ts->{NewDaemons} }) {
            $updatercd->("$d",$pri);
            $pri++;
        }
    } else {
        my $initd= $ts->{OldDaemonInitd};
        $updatercd->($initd,93) if defined $initd;
        $updatercd->('xenbridge',38) if $ts->{OldSeparateBridgeInitd};
    }
    target_cmd_root($ho, $cmd);
}

sub nodhcp () {
    my ($iface,$bridgex);
    if ($initscripts_nobridge) {
        $iface= 'xenbr0';
        $bridgex= <<END;
    bridge_ports eth0
    bridge_fd 0
    bridge_stp off
END
    } else {
        $iface= 'eth0';
        $bridgex= '';
    }
logm("iface $iface >$initscripts_nobridge<");
    target_editfile_root($ho, "/etc/network/interfaces",
                         "etc-network-interfaces", sub {
        my $suppress= 0;
        while (<EI>) {
            $suppress= 0 unless m/^\s+/;
            s/^ \s* allow-hotplug \s+ (?: eth0 | xenbr0 ) \s* $
                /auto $iface\n/x;
            if (m/^\s* iface \s+ (?: eth0 | xenbr0 ) \s+ inet \s /x) {
                $suppress= 1;
                print EO <<END;
iface $iface inet static
    address $ho->{Ip}
    netmask $c{NetNetmask}
    gateway $c{NetGateway}
$bridgex
END
            }
            print EO or die $!
                unless $suppress;
        }
    });
}    

if ($checkmode) {
    extract();
} else {
    die if @hos > 1;
    $ho= $hos[0];
    
    packages();
    extract();
    adjustconfig();
    setupboot();
    setupinitd();
    nodhcp();
}
