#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict qw(vars);
use DBI;
use Osstest;
use POSIX;
use Osstest::TestSupport;

tsreadconfig();

our ($whhost) = @ARGV;
$whhost ||= 'host';
our $ho= selecthost($whhost);
exit 0 if $ho->{SharedReady};

our ($vg,$lv);

our $lvleaf = 'osstest_home';
our $pe_size;
our $extended_pes = 0;

sub gb2pe ($) {
    my ($gb) = @_;
    return $gb *1024.0*1024.0 / $pe_size;
}

sub overall_limit_pe ($) {
    my ($pevar) = @_;
    my $overall_limit = $r{build_lvextend_max};
    return unless defined $overall_limit && $overall_limit =~ m/^\d/;
    my $allow = floor(gb2pe($overall_limit)) - $extended_pes;
    if ($$pevar > $allow) {
	logm("applying overall lvextend limit ${overall_limit}G");
	$$pevar = $allow;
    }
    $extended_pes += $$pevar;
}

sub determine_vg_lv () {
    $vg=
        $ho->{Suite} =~ m/jessie/
        ? "$ho->{Name}-vg"
        : $ho->{Name};
    $lv = "/dev/$vg/$lvleaf";
}

sub lvextend_stage1 () {
    target_cmd_root($ho, <<END);
        set -ex; if ! test -f /root/swap_osstest_enabled; then
            lvcreate -L 10G -n swap_osstest_build $vg ||:
            mkswap /dev/$vg/swap_osstest_build ||:
            swapon /dev/$vg/swap_osstest_build
            touch /root/swap_osstest_enabled
        fi
END

    lvextend1('disk extend initial',       300);
}

sub lvextend_stage2 () {
    lvextend1('disk extend subsequent',  undef);
}

sub vginfo () {
    my $vginfo= target_cmd_output_root($ho, "vgdisplay --colon $vg");
    my @vginfo= split /\:/, $vginfo;
    @vginfo >= 17 or die "$vginfo ?";
    return @vginfo;
}

sub lvcreate () {
    target_cmd_output_root($ho,
			   "lvdisplay $lv || lvcreate -l 1 -n $lvleaf $vg");
}

sub lvextend1 ($$$) {
    my ($what, $max_more_gb)  = @_;

    my @vginfo = vginfo();
    $pe_size= $vginfo[12];

    my $do_limit_pe = sub { };
    if (defined $max_more_gb) {
	my $max_more_pe = floor(gb2pe($max_more_gb));
	$do_limit_pe = sub {
	    my ($pevar, $twhat) = @_;
	    logm("$what: $twhat: limit ${max_more_gb}G,".
		 " want $$pevar<=$max_more_pe");
	    if ($$pevar >= $max_more_pe) {
		$$pevar = $max_more_pe;
		$do_limit_pe = sub {
		    my ($pevar, $twhat) = @_;
		    logm("$what: $twhat: already limited");
		    $$pevar = 0;
		};
	    }
	};
    }

    my $more_pe= 0;

    my $pvinfos= target_cmd_output_root($ho, "pvdisplay --colon");
    my $stripe_minfree;
    my $stripe_count=0;
    foreach my $pvinfo (split /\n/, $pvinfos) {
        my @pvinfo= split /\:/, $pvinfo;
        @pvinfo >= 10 or die "$pvinfo ?";
        my $pv_name= $pvinfo[0];  $pv_name =~ s/^\s+//;
        my $pv_vg= $pvinfo[1];
        my $pv_free_pe= $pvinfo[9];
        if ($pv_vg ne $vg) {
            logm("$what: $pv_name: vg $pv_vg != $vg");
            next;
        }
        logm("$what: $pv_name: $pv_free_pe free PEs");
        next unless $pv_free_pe;
        if (!defined($stripe_minfree) ||
            $pv_free_pe < $stripe_minfree) {
            $stripe_minfree= $pv_free_pe;
        }
        $stripe_count++;
    }
    $stripe_minfree=0 if !defined $stripe_minfree;
    logm("$what: $stripe_count stripe(s) x $stripe_minfree PEs");

    my $stripes_free = $stripe_count * $stripe_minfree;
    $do_limit_pe->(\$stripes_free, 'striped');
    if ($stripe_minfree && $stripe_count>1
	&& $ho->{Suite} !~ m/wheezy/ # bugs.debian.org/736173
	) {
        overall_limit_pe(\$stripes_free);
        $more_pe += $stripes_free;
        target_cmd_root($ho, "lvextend -i$stripe_count -l +$stripes_free $lv");
    }

    @vginfo = vginfo();
    my $vg_more_free_pe= $vginfo[15];

    $do_limit_pe->(\$vg_more_free_pe, 'unstriped');

    if ($vg_more_free_pe) {
        logm("$what: unstriped $vg_more_free_pe PEs");
        overall_limit_pe(\$vg_more_free_pe);
        $more_pe += $vg_more_free_pe;
        target_cmd_root($ho, "lvextend -i1 -l +$vg_more_free_pe $lv");
    }

    my $timeout = 2000 + int($pe_size * 0.000003 * $more_pe);
    logm("$what: ${pe_size}k x $more_pe (timeout=$timeout)");
}

sub replace_home () {
    my $dir = '/home/osstest';
    my $mapper = lv_dev_mapper($vg,$lvleaf);
    my ($fstype,@opts) = qw(ext3 -m 0 -O sparse_super);
    target_cmd_root($ho, <<END, 1000);
        set -ex
	if mount | sed -e 's/^[^ ].* on //; s/ .*//' | grep -F '$dir'; then
	    exit 0
	fi
	mkfs -t $fstype @opts $lv
        mount $lv /mnt
	rsync -aHx --numeric-ids $dir/. /mnt/.
	rm -rf $dir
	mkdir -m 2700 $dir
	echo '$mapper $dir $fstype defaults 0 0' >>/etc/fstab
	umount /mnt
	mount $dir
END

        # for convenience, here is a small scriptlet to undo this:
        <<'END';
#!/bin/sh
set -ex
cd /home
rm -rf osstest.new
rsync -aH --numeric-ids osstest/. osstest.new
umount /home/osstest
rmdir osstest
mv osstest.new osstest
lvremove -f /dev/`uname -n`/osstest_home
END
}

sub prep () {
    my @packages = qw(mercurial
                      build-essential bin86 bcc iasl bc
                      flex bison cmake
                      libpci-dev libncurses5-dev libssl-dev python-dev
                      libx11-dev git-core uuid-dev gettext gawk
                      libsdl-dev libyajl-dev libaio-dev libpixman-1-dev
                      libglib2.0-dev liblzma-dev pkg-config
                      autoconf automake libtool xsltproc
                      libxml2-utils libxml2-dev
                      libdevmapper-dev w3c-dtd-xhtml libxml-xpath-perl
                      ccache nasm checkpolicy);

    if ($ho->{Suite} =~ m/jessie/) {
	push(@packages, "libnl-route-3-dev");
    } else {
	push(@packages, "libnl-dev");
    }
    target_install_packages($ho, @packages);
    target_cmd_root($ho, "chmod -R a+r /usr/share/git-core/templates");
    # workaround for Debian #595728

    if ($ho->{Suite} !~ m/lenny/) {
        target_putfilecontents_stash($ho,60,<<'END','/home/osstest/.hgrc');
[extensions]
mq=
END
    }

    if ($ho->{Suite} !~ m/lenny|squeeze/) {
        target_install_packages($ho, 'libfdt-dev');
    }
    if ($r{arch} eq 'amd64' && $ho->{Suite} =~ m/wheezy/) {
        target_install_packages($ho, 'libc6-dev-i386');
    }
}

sub ccache_setup () {
    my $opts= get_host_property($ho, 'build ccache opts', '');
    if (length $opts) {
        target_cmd($ho, "ccache $opts");
    }
}

if (!$ho->{Flags}{'no-reinstall'}) {
    determine_vg_lv();
    lvcreate();
    lvextend_stage1();
    prep();
    lvextend_stage2();
    replace_home();
    ccache_setup();
}
$mjobdb->jobdb_resource_shared_mark_ready
   ($ho->{Ident}, $ho->{Name}, "build-".$ho->{Suite}."-".$r{arch});
