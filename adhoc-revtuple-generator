#!/usr/bin/perl -w

use strict qw(vars);
use IO::File;
use IO::Handle;
no warnings qw(recursion);

our $num= 1000;

open DEBUG, ">/dev/null" or die $!;

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_ = shift @ARGV;
    last if $_ eq '--';
    die "stdin not meaningful" if $_ eq '-';
    die "no long options" if m/^--/;
    while (m/^-./) {
        if (m/^-n([1-9]\d*)$/) {
            $num= $1;
            last;
        } elsif (s/^-D/-/) {
            open DEBUG, ">&2" or die $!;
            STDOUT->autoflush(1);
            DEBUG->autoflush(1);
        } else {
            die "unknown option \`$_'";
        }
    }
}

my $xu= 'http://hg.uk.xensource.com/xen-unstable.hg';
my $qemu= 'git://mariner.uk.xensource.com/qemu-xen-unstable.git';

sub max {
    my $max;
    foreach my $item (@_) {
	next if defined $max and $max>=$item;
	$max= $item;
    }
    return $max;
}
sub min {
    return -max(map { -$_ } @_);
}

sub shellcmd ($) {
    $?=0; $!=0;
    my $r= system($_[0]);
    die "$_[0] $r $? $!" if $r;
}

sub git_generator ($) {
    my ($tree) = @_;
    print DEBUG "GIT-GEN ".pmap($tree).".\n";
    my $treename= $tree->{Treename};
    shellcmd("set -e; exec >&2; cd repos/$treename && git-pull");
    my $cmd= "cd repos/$treename && git-log --pretty=raw --date-order";
    my $fh= new IO::File;
    open $fh, "$cmd |" or die $!;
    return sub {
	my (%r);
        local $_;
	for (;;) {
	    defined($_= <$fh>) or die "$cmd $!";
	    if (m/^\s/) {
		last if $r{commit};
		next;
	    }
	    m/^(\w+)\s(.*)$/ or die "$cmd: $_ ?";
	    push @{ $r{$1} }, $2;
	}
	die unless @{ $r{parent} } >= 1;
	die unless @{ $r{commit} } == 1;
	die unless @{ $r{committer} } == 1;
	die unless $r{committer}[0] =~ m/ (\d+)(?: [-+]\d{4})$/;
	my $date= $1;
	return {
            Generator => "git_generator:$treename",
	    Commit => $r{commit}[0],
	    Parents => $r{parent},
	    Date => $date
	};
    };
}

sub hg_generator ($) {
    my ($tree) = @_;
    local $_;
    print DEBUG "HG-GEN ".pmap($tree).".\n";
    my $treename= $tree->{Treename};
    shellcmd("set -e; exec >&2; cd repos/$treename && hg pull -u");
    my $cmd= "cd repos/$treename && hg log --template '".
	"{node|short}\n".
	"{node|short} {date}\n".
	"{files}\n".
	"{parents}\n".
	"'";
    my $fh= new IO::File;
    open $fh, "$cmd |" or die "$cmd $!";
    $_= <$fh>;
    m/^\w+$/ or die "$_ $! ?";
    return sub {
        local $_;
	my $r= {
            Parents => [],
            Generator => "hg_generator:$treename",
        };
	defined($_= <$fh>) or die "$cmd $!";
	m/^(\w+) (\d+)(?:\.\d+)?(?:[-+]\d+)?$/ or die "$cmd $_ ?";
	$r->{Commit}= "$1";
	$r->{Date}= $2;
	defined($_= <$fh>) or die "$cmd $!";
	chomp;
	$r->{Files}= [ split / / ];
	defined($_= <$fh>) or die "$cmd $!";
	chomp;
	if (length) {
	    foreach my $parentspec (split / /) {
		$parentspec =~ m/^\d+\:(\w+)$/ or die "$parentspec ?";
		push @{ $r->{Parents} }, $1;
	    }
	    defined(<$fh>) or die "$cmd $!";
	} else {
	    defined($_= <$fh>) or die "$cmd $!";
	    chomp;
	    push @{ $r->{Parents} }, $_;
	}
	print DEBUG "GEN hg_generator $treename $r->{Commit}\n";
	return $r;
    }
}

sub pmap ($) {
    my ($map) = @_;
    return join ' ', map {
        my $v= $map->{$_};
        "$_=".(!defined $v ? '<undef>' :
               ref $v eq 'ARRAY' ? "[@$v]" :
               $v)
        } sort keys %$map;
}

sub gen2_graph ($) {
    my ($gen) = @_;
    my $graph= { };
    for (my $count=0; $count<$num; $count++) {
	my $rev= $gen->();
	print DEBUG "GEN2 ", pmap($rev), " .\n";
	if (!exists $graph->{Head}) { $graph->{Head}= $rev->{Commit} }
	$graph->{ $rev->{Commit} }= $rev;
    }
    print DEBUG "GEN2 head $graph->{Head}.\n";
    return $graph;
}

sub tree2graph ($) {
    my ($tree)= @_;
    my $g= $tree->{Graph};
    if (!defined $g) {
        local ($_);
        print DEBUG "TREE2GRAPH IN ".pmap($tree).".\n";
        $tree->{Graph}= $g= $tree->{MakeGraph}($tree);
        print DEBUG "TREE2GRAPH OUT ".pmap($tree).".\n";
    }
    return $g;
}

sub xu_withtag_generator ($) {
    my ($tree) = @_;
    my $xengen= tree_get_gen($tree->{Xen});
    my $xentree= $tree->{Xen}{Treename};
    my $qemutree= $tree->{Qemu}{Treename};
    my $targetqemu= 'unknown';
    return sub {
	my $xenrev= $xengen->();
	print DEBUG "XUWT (tq=$targetqemu) $xenrev->{Commit}\n";
	if ($targetqemu eq 'unknown') {
	    my $nodeonly= $xenrev->{Commit};
	    $nodeonly =~ s/^\d+\://;
	    open CMK, "cd repos/$xentree &&
                       hg cat -r $nodeonly Config.mk |"
			 or die $!;
	    while (<CMK>) {
		next unless m/^QEMU_TAG\s*[:?]?\=\s*(\S+)\s*$/;
		$targetqemu= $1;
	    }
	    if ($targetqemu !~ m/^[0-9a-f]+$/) {
		die if $targetqemu =~ m/[^-+._0-9a-zA-Z]/;
		die unless $targetqemu =~ m/^[^-]/;
		$!=0; $?=0;
		$targetqemu= `cd repos/$qemutree &&
                              git-rev-parse '$targetqemu'`;
		die "$! $?" if (!defined $targetqemu) or $?;
		chomp $targetqemu;
	    }
	}
	die unless $targetqemu =~ m/^[0-9a-f]+$/;
	$xenrev->{QemuTag} = $targetqemu;

	$targetqemu= 'unknown' if
	    grep { $_ eq 'Config.mk' } @{ $xenrev->{Files} };

        $xenrev->{Generator} .= ";with-qemu:$qemutree";
	return $xenrev;
    }
}

# Revision graphs are:
#  $graph->{Head}
#  $graph->{"<revision>"}{Parents}[0] = "<another revision>"
#  $graph->{"<revision>"}{Date} = <time_t>

sub xenplusqemu_graph ($) {
    my ($tree) = @_;
    print DEBUG "XENPLUSQEMU_GRAPH ".pmap($tree).".\n";

    my $xentree= $tree->{Xen}{Treename};
    my $qemutree= $tree->{Qemu}{Treename};

    my $x= gen2_graph(xu_withtag_generator($tree));
    my $q= tree2graph($tree->{Qemu});

    my $xhead= $x->{Head};
    my $qhead= $x->{$xhead}{QemuTag};
    my $head= $xhead.' '.$qhead;
    my $result= {
	Head => $head,
    };

    my ($xfindparents, $qfindparents);

    $qfindparents= sub {
	my ($xnode, $xparent, $qnode, $qtarg, $depth) = @_;
	return unless defined $xparent and defined $qtarg;
        my $node= "$xnode $qnode";
	printf DEBUG "QFP %d %s %s %s %s ", $depth,
	    $xnode, $xparent, $qnode, $qtarg;
        if (exists $result->{$node}) {
            print DEBUG "already.\n";
            return;
        }
	if ($qnode eq $qtarg) {
	    my $chosen= "$xparent $qnode";
	    print DEBUG "   XP  $node .. $chosen\n";
	    push @{ $result->{$node}{Parents} }, $chosen;
	    $xfindparents->($xparent, $qtarg, $depth+1);
	    return;
	}
	foreach my $qparent (@{ $q->{$qnode}{Parents} }) {
	    my $chosen= "$xnode $qparent";
	    print DEBUG "   QP  $node .. $chosen\n";
	    push @{ $result->{$node}{Parents} }, $chosen;
	    $qfindparents->($xnode, $xparent, $qparent, $qtarg, $depth+1);
	}
    };

    $xfindparents= sub {
	my ($xnode,$qnode,$depth) = @_;
	return unless defined $xnode and defined $qnode;
	printf DEBUG "XFP %d                    %s %s\n",
	    $depth, $xnode, $qnode;
	foreach my $xparent (@{ $x->{$xnode}{Parents} }) {
	    $qfindparents->($xnode, $xparent,
			    $qnode, $x->{$xparent}{QemuTag}, $depth+1);
	}
    };

    $xfindparents->($xhead, $qhead, 0);

    foreach my $node (keys %$result) {
	next if $node eq 'Head';
	my ($xnode, $qnode) = split / /, $node;
	die "$node ?" unless defined $qnode;
	$result->{$node}{Date}= max($x->{$xnode}{Date},
				    $q->{$qnode}{Date});
    }
    return $result;
}

sub coalesce {
    my (@trees)= @_;
    my (@graphs, @heads);
    foreach my $tree (@trees) {
        my $graph= tree2graph($tree);
        push @graphs, $graph;
        my $head= length $tree->{Latest} ? $tree->{Latest} : $graph->{Head};
        push @heads, $head;
        print DEBUG "COA INIT ".pmap($tree)." | head=$head\n";
    }

    print DEBUG "COA HEAD (@heads)\n";
    
    my $out= {
	Head => "@heads"
    };

    my $descend;
    $descend= sub {
	my ($depth, @node) = @_;
	my $node = "@node";
	print DEBUG "COA $depth ($node) ";
        if (exists $out->{$node}) {
            print DEBUG "already.\n";
            return;
        }
	# we find the newest component revision, and descend parents
	#  for our revisioncommit-tuple by looking at the parents of
	#  the newest component
        # except that we prefer not to look at parents of the node
        #  marked "Earliest", in the hope that our descent will
        #  eventually find the whole earliest tuple
	my $explode_date= 0;
	my $explode_isearliest= 1;
	my $explode_i;
	for (my $i=0; $i<@graphs; $i++) {
	    my $this_date= $graphs[$i]{ $node[$i] }{Date};
	    next unless defined $this_date;
            my $this_isearliest= 0+($node[$i] eq $trees[$i]{Earliest});
            next if (
                     $explode_isearliest <=> $this_isearliest  or
                     $this_date          <=> $explode_date
                     ) <= 0;
	    $explode_date=       $this_date;
	    $explode_isearliest= $this_isearliest;
	    $explode_i=          $i;
	}
	if (!defined $explode_i) {
	    print DEBUG "...end.\n";
	    return;
	}
	$out->{$node}{Date}= $explode_date;
	my $parents= $graphs[$explode_i]{ $node[$explode_i] }{Parents};
	print DEBUG "#$explode_i $explode_isearliest".
            " $explode_date  x".scalar(@$parents)."\n";

	foreach my $subparent (@$parents) {
	    $node[$explode_i]= $subparent;
	    push @{ $out->{$node}{Parents} }, "@node";
	    print DEBUG "COA $depth ($node) #$explode_i $explode_isearliest".
		         " $explode_date .. (@node)\n";
	    $descend->($depth+1, @node);
	}
    };

    $descend->(0, @heads);

    return $out;
}

sub tree_get_gen ($) {
    my ($tree)= @_;
    print DEBUG "TREE-GET-GEN ".pmap($tree).".\n";
    return $tree->{Gen}($tree);
}
sub makegraph_fromgen ($) {
    my ($tree)= @_;
    print DEBUG "MAKEGRAPH-FROMGEN ".pmap($tree).".\n";
    return gen2_graph(tree_get_gen($tree));
}

sub main () {
    my @trees;
    local $_;
    
    foreach (my $i=0; $i<@ARGV; $i++) {
        $_= $ARGV[$i];
        my $tree= {
            MakeGraph => \&makegraph_fromgen,
            Outixes => [ $i ],
            Earliest => '',
            Latest => '',
        };
        if (s/\#(\w+)\-(\w+)$//) {
            $tree->{Earliest}= $1;
            $tree->{Latest}= $2;
        }
        if (m,/(\w[^/.]+)\.git$,) {
            $tree->{Gen}= \&git_generator;
            $tree->{Treename}= $1;
	} elsif (m,/(\w[^/.]+\.hg)$,) {
            $tree->{Gen}= \&hg_generator;
            $tree->{Treename}= $1;
        } else {
            die "unknown tree format $_ ?";
        }

        push @trees, $tree;
    }

    print DEBUG "MAIN INIT trees=@trees.\n";
    print DEBUG "MAIN INIT names=".
        (join ' ', map { $_->{Treename} } @trees).".\n";
    print DEBUG "MAIN INIT outixes=".
        (join ' | ', map { @{ $_->{Outixes} } } @trees).".\n";

    my (@xis, @qis);
    foreach (my $i=0; $i<@trees; $i++) {
        $_= $trees[$i]{Treename};
        push @xis, $i if m/^xen-(?:unstable|4)/;
        push @qis, $i if m/^qemu-(?:xen-unstable|4)/;
    }
    print DEBUG "MAIN xis=@xis qis=@qis.\n";

    if (@xis == 1 && @qis == 1) {
        my $x= $trees[$xis[0]];
        my $q= $trees[$qis[0]];
        $trees[$xis[0]]= {
            Treename => "$x->{Treename}+$q->{Treename}",
            Xen => $x,
            Qemu => $q,
            MakeGraph => \&xenplusqemu_graph,
            Outixes => [ @{ $x->{Outixes} }, @{ $q->{Outixes} } ],
        };
        foreach my $el (qw(Earliest Latest)) {
            my $earl= "$x->{$el} $q->{$el}";
            $earl='' if $earl =~ m/^ | $/;
            $trees[$xis[0]]{$el}= $earl;
        }
        $q->{Outixes} = undef;
    }

    @trees= grep { defined $_->{Outixes} } @trees;

    my @graphs= map { tree2graph($_) } @trees;
    my @outixes= map { my $ox= $_->{Outixes}; defined $ox ? @$ox : () } @trees;
    my $graph= coalesce(@trees);
    
    print DEBUG "MAIN THEN trees=@trees.\n";
    print DEBUG "MAIN THEN names=".
        (join ' ', map { $_->{Treename} } @trees).".\n";
    print DEBUG "MAIN THEN graphs=@graphs.\n";
    print DEBUG "MAIN THEN outixes=@outixes.\n";

    my $pnodename= sub {
        my ($node)= @_;
        my @in= split / /, $node;
        die "($node) @in != @outixes"unless @in==@outixes;
        my @out;
        for (my $i=0; $i<@in; $i++) {
            $out[$outixes[$i]]= $in[$i];
        }
        die if grep { !defined $_ } @out;
        die unless @out==@in;
        print "@out\n" or die $!;
    };

    my $descend;
    $descend= sub {
        my ($node)= @_;
        my $n= $graph->{$node};
        return unless defined $n;
        print DEBUG "DESC $node ".pmap($n);
        if ($n->{Descended}++) {
            print DEBUG " already $n->{Descended}.\n";
            return;
        }
        printf DEBUG ":\n";
        my $parents= $n->{Parents};
        $pnodename->($node);
        printf "%s %d\n", $n->{Date}, scalar(@$parents) or die $!;
        $pnodename->($_) foreach @$parents;
        $descend->($_)   foreach @$parents;
    };

    $descend->($graph->{Head});
    print ".\n" or die $!;
}

main();
