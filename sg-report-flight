#!/usr/bin/perl -w

use strict qw(refs vars);

use DBI;
use Osstest;
use IO::Handle;

our $specflight;
our %specver;
our @blessings;
our $mro;

open DEBUG, ">/dev/null";
open MRO, ">/dev/null";

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--?$/;
    if (m/^--(this|that)-([^=]+)\=([^=]+)$/) {
        $specver{$1}{$2}= $3;
    } elsif (m/^--machine-readable-output=(.*)$/) {
        $mro= $1;
        open MRO, "> $mro.new" or die "$mro.new $!";
    } elsif (m/^--blessings?=(.*)$/) {
        push @blessings, split ',', $1;
    } elsif (m/^--debug/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
        die "$_ ?";
    }
}

if (@ARGV && !defined $specflight) {
    $specflight= shift @ARGV;
}
!@ARGV or die;

push @blessings, 'real' unless @blessings;

csreadconfig();

# formatting settings
our $jl= 30;
our $sl= 30;
our $rl= 9;
our $cw= 79;
our $tl= 20;

our $blessingscond= '('.join(' OR ', map { "blessing=?" } @blessings).')';

sub findaflight ($$) {
    my ($thisthat, $sub) = @_;

    die $thisthat unless keys %{ $specver{$thisthat} };

    my $flightsq= <<END;
        SELECT flight FROM flights
            WHERE $blessingscond
            ORDER BY flight DESC
            LIMIT 1000
END
    #print DEBUG "===\n$flightsq\n===\n";
    $flightsq= $dbh_tests->prepare($flightsq);
    $flightsq->execute(@blessings);

    my $whynotq= <<END;
            SELECT * FROM runvars
                WHERE flight=? AND (FALSE
END
    foreach my $tree (keys %{ $specver{$thisthat} }) {
        my $v= $specver{$thisthat}{$tree};
        $whynotq .= <<END
                  OR (name='built_revision_$tree' AND
                      NOT (val = '$v' OR val LIKE '%:$v'))
END
    }
    $whynotq .= <<END;
                                    )
                LIMIT 1
END
    #print DEBUG "===\n$whynotq\n===\n";
    $whynotq= $dbh_tests->prepare($whynotq);

    while (my ($tflight) = $flightsq->fetchrow_array) {
        $whynotq->execute($tflight);
        my $row= $whynotq->fetchrow_arrayref();
        my $whynot;
        if ($row) {
            $whynot= "mismatch @$row";
        } else {
            $whynot= $sub->($tflight);
        }
        return $tflight if !defined $whynot;
        print DEBUG " $tflight $whynot\n";
    }
    return undef;
}

sub findspecflight () {
    return if defined $specflight;
    $specflight= findaflight('this', sub { return undef; });
    die unless defined $specflight;
}

sub examineflight ($) {
    my ($flight) = @_;
    my @jobtexts;
    my %fails;
    my %statuscounts;
    my $jobsummary= '';
    
    my $flightinfo= $dbh_tests->selectrow_hashref(<<END);
        SELECT * FROM flights
            WHERE flight=$flight
END

    my $jobs= $dbh_tests->selectall_arrayref(<<END, { Slice => {} });
        SELECT * FROM jobs
            WHERE flight=$flight
            ORDER BY job
END

    foreach my $j (@$jobs) {
	$statuscounts{$j->{status}}++;

	my $jobtext= sprintf "%s:\n", $j->{job};

	my $sth= $dbh_tests->prepare(<<END);
	    SELECT * FROM steps
		WHERE flight=$flight AND job='$j->{job}'
		ORDER BY stepno
END
        $sth->execute();

        $jobsummary .= sprintf " %-${jl}s %-${rl}s\n", $j->{job}, $j->{status};

	while (my $s= $sth->fetchrow_hashref()) {
	    $jobtext .= sprintf "%2d %-${sl}s %-${rl}s\n",
	        $s->{stepno}, $s->{testid}, $s->{status};
            if ($s->{status} ne 'pass') {
                my $failkey= "$j->{job}.$s->{testid}";
                my $failval= {
                    Job => $j,
                    Step => $s
                };
                $fails{$failkey}= $failval;
            }
	}

        my $revh= $dbh_tests->prepare(<<END);
            SELECT * FROM runvars
                WHERE flight=$flight AND job='$j->{job}'
                  AND name like 'built_revision_%'
                ORDER BY name
END
        $revh->execute();
        while (my $r= $revh->fetchrow_hashref()) {
            my $br= $r->{name};
            $br =~ s/^built_revision_// or die "$br ?";
            $jobtext .= sprintf " %-15s %-.20s\n", $br, $r->{val};
        }

	push @jobtexts, [ split /\n/, $jobtext ];
    }

    my $outcomes= join '/', sort keys %statuscounts;
    my $outcome;
    if ($outcomes eq 'pass') {
        $outcome= 'all pass';
    } elsif ($outcomes eq 'fail') {
        $outcome= 'ALL FAIL';
    } elsif ($outcomes =~ m,^(?:blocked/)?(?:fail/)?pass$,) {
        $outcome= 'FAIL';
    } else {
        $outcome= "trouble: $outcomes";
    }

    return {
        Flight => $flight,
        FlightInfo => $flightinfo,
        JobTexts => \@jobtexts,
        Failures => \%fails,
        StatusCounts => \%statuscounts,
        OutcomeSummary => $outcome,
        JobsSummary => $jobsummary,
    };
}

sub printversions ($) {
    my ($thisthat) = @_;
    my ($sv) = $specver{$thisthat};
    foreach my $k (sort keys %$sv) {
        printf " %-${tl}s %s\n", $k, $sv->{$k} or die $!;
        print MRO "version $thisthat $k $sv->{$k}\n" or die $!;
    }
}

sub printout ($) {
    my ($r) = @_;
    print <<END
oss xen test $r->{Flight}: $r->{OutcomeSummary}

flight $r->{Flight} $r->{FlightInfo}{blessing}

tests which did not succeed:
END
        or die $!;
    foreach my $failk (sort keys %{ $r->{Failures} }) {
        my $failv= $r->{Failures}{$failk};
        my $s= $failv->{Step};
        my $j= $failv->{Job};
        my $text= (sprintf" %-${jl}s %2d %-${sl}s %-${rl}s",
                   $j->{job}, $s->{stepno}, $s->{testid}, $s->{status});
        if ($failv->{Regression}) {
            $text .= 'REGRESSION';
        } elsif (defined $failv->{JustifyingFlight}) {
            if ($failv->{JustifyingFlight} eq 'never') {
                $text .= "never pass";
            } else {
                $text .= $failv->{JustifyingFlight};
            }
        }
        $text =~ s/ *$//;
        while (length($text) > $cw) { last unless $text =~ s/(.* ) /$1/; }
        print $text, "\n";
    }
    print "\n" or die $!;

    if ($specver{this}) {
        print "version targeted for testing:\n" or die $!;
        printversions('this');
    }
    if ($specver{that}) {
        print "baseline version:\n" or die $!;
        printversions('that');
        print <<'END' or die $!;
(Individual test failures are shown as REGRESSION above if they never failed
in the baseline.  If they did, a flight in which they failed is shown.
"never pass" indicates that this test has never passed with any version.)
END
    }

    print "\njobs:\n", $r->{JobsSummary}, "\n" or die $!;

    foreach my $jt (@{ $r->{JobTexts} }) {
	print '-'x$cw or die $!;
        print "\n" or die $!;
        print join "\n", @$jt or die $!;
        print "\n" or die $!;
    }

    my $hostname= `hostname -f`;
    $? and die $?;  chomp $hostname;

    my $logs= $c{Logs};

    print <<END or die $!;

------------------------------------------------------------
sg-report-flight on $hostname
logs: $logs
stash: $c{Stash}
images: $c{Images}

$c{ReportTrailer}
END
}

sub justifyfailures ($) {
    my ($fi) = @_;
    return unless $specver{that};

    my @failures= values %{ $fi->{Failures} };

    my $anypassq= <<END;
        SELECT * FROM flights NATURAL JOIN steps
            WHERE $blessingscond
              AND job=? and testid=? and status='pass'
            LIMIT 1
END
    $anypassq= $dbh_tests->prepare($anypassq);

    foreach my $failv (@failures) {
        my $j= $failv->{Job};
        my $s= $failv->{Step};
        my $st= $s->{status};
        print DEBUG "justifying $j->{job} $s->{testid} $st\n";

        $anypassq->execute(@blessings, $j->{job}, $s->{testid});
        if (!$anypassq->fetchrow_hashref()) {
            print MRO "never-passed $j->{job} $s->{testid} $st\n";
            print DEBUG " never passed\n";
            $failv->{JustifyingFlight}= 'never';
            next;
        }

        if ($st ne 'fail') {
            print MRO "broken $j->{job} $s->{testid} $st\n";
            print DEBUG " not a fail, unjustifiable\n";
            next;
        }
        my $justflight= findaflight('that', sub {
            my ($chkflight) = @_;
            my $checkq= $dbh_tests->prepare(<<END);
                SELECT status FROM steps WHERE flight=? AND job=? AND testid=?
END
            $checkq->execute($chkflight, $j->{job}, $s->{testid});
            my ($chkst) = $checkq->fetchrow_array();
            return "step not executed" unless defined $chkst;
            return "benchmark was $st" unless $chkst eq $st;
            return undef;
        });
        if (!defined $justflight) {
            print MRO "regression $j->{job} $s->{testid}\n" or die $!;
            $failv->{Regression}= 1;
            print DEBUG " unjustified\n";
            next;
        }
        print DEBUG " justified by $justflight\n";
        $failv->{JustifyingFlight}= $justflight;
    }
    if (!@failures) {
        print MRO "tolerable\nperfect\n" or die $!;
    } elsif (grep { $_->{Regression} } @failures) {
        $fi->{OutcomeSummary}= "regressions - $fi->{OutcomeSummary}";
    } elsif (!grep { !defined $_->{JustifyingFlight} } @failures) {
        $fi->{OutcomeSummary}= "tolerable $fi->{OutcomeSummary}";
        print MRO "tolerable\n" or die $!;
    } else {
        # not tolerable
    }
}

findspecflight();
my $fi= examineflight($specflight);
justifyfailures($fi);
printout($fi);

if (defined $mro) {
    close MRO or die $!;
    rename "$mro.new",$mro or die $!;
}
