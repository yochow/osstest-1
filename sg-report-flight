#!/usr/bin/perl -w

use strict qw(refs vars);

use DBI;
use Osstest;
use IO::Handle;
use HTML::Entities;

our $specflight;
our %specver;
our @blessings;
our $mro;
our $htmlout;
our $branch;

open DEBUG, ">/dev/null";
open MRO, ">/dev/null";

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--?$/;
    if (m/^--(this|that)-([^=]+)\=([^=]+)$/) {
        $specver{$1}{$2}= $3;
    } elsif (m/^--machine-readable-output=(.*)$/) {
        $mro= $1;
        open MRO, "> $mro.new" or die "$mro.new $!";
    } elsif (m/^--html-output=(.*)$/) {
        $htmlout= $1;
    } elsif (m/^--blessings?=(.*)$/) {
        push @blessings, split ',', $1;
    } elsif (m/^--debug/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
        die "$_ ?";
    }
}

@ARGV==1 or die;

$_= shift @ARGV;
if (m/^\d+$/) {
    $specflight= $_;
} else {
    $branch= $_;
}

push @blessings, 'real' unless @blessings;

csreadconfig();

# formatting settings
our $jl= 28;
our $sl= 28;
our $rl= 9;
our $cw= 79;
our $tl= 20;

our $blessingscond= '('.join(' OR ', map { "blessing=?" } @blessings).')';

sub findaflight ($$) {
    my ($thisthat, $sub) = @_;

    die $thisthat unless keys %{ $specver{$thisthat} };

    my $flightsq= <<END;
        SELECT flight FROM flights
            WHERE branch=?
              AND $blessingscond
            ORDER BY flight DESC
            LIMIT 1000
END
    #print DEBUG "===\n$flightsq\n===\n";
    $flightsq= $dbh_tests->prepare($flightsq);
    $flightsq->execute($branch, @blessings);

    my $revisionsq= <<END;
            SELECT job, val FROM runvars
                WHERE flight=?
		  AND name=?
		GROUP BY job, val
END
    #print DEBUG "===\n$mismatchq\n===\n";
    $revisionsq= $dbh_tests->prepare($revisionsq);

    while (my ($tflight) = $flightsq->fetchrow_array) {
	my $whynot;
	foreach my $tree (keys %{ $specver{$thisthat} }) {
	    my $v= $specver{$thisthat}{$tree};
	    $revisionsq->execute($tflight, "built_revision_$tree");
	    my $revisions= $revisionsq->fetchall_arrayref({});
	    if (!@$revisions) {
		$whynot= "no built $tree";
		last;
	    }
	    my ($wrong) = grep {
		$_->{val} !~ m/^(?: .*: )? $v /x;
	    } @$revisions;

	    if (defined $wrong) {
		$whynot= "mismatch $tree $wrong->{job} $wrong->{val} != $v";
		last;
	    }
	}
        $whynot= $sub->($tflight) if !defined $whynot;
        return $flight            if !defined $whynot;
        print DEBUG " $tflight $whynot\n";
    }
    return undef;
}

sub findspecflight () {
    if (defined $specflight) {
        ($branch) = $dbh_tests->selectrow_array(<<END, {}, $specflight);
            SELECT branch FROM flights WHERE flight=?
END
        die "$flight branch ?" unless defined $branch;
    } else {
        $specflight= findaflight('this', sub { return undef; });
        die unless defined $specflight;
    }
}

sub examineflight ($) {
    my ($flight) = @_;
    my @jobtexts;
    my %fails;
    my %statuscounts;
    my $jobsummary= '';

    my @gridcol_job;
    my @gridrow_rowspec;
    my %grid;

    my $flightinfo= $dbh_tests->selectrow_hashref(<<END);
        SELECT * FROM flights
            WHERE flight=$flight
END

    my $jobs= $dbh_tests->selectall_arrayref(<<END, { Slice => {} });
        SELECT * FROM jobs
            WHERE flight=$flight
            ORDER BY job
END

    foreach my $j (@$jobs) {
        push @gridcol_job, $j->{job};

	$statuscounts{$j->{status}}++;

	my $jobtext= sprintf "%s:\n", $j->{job};

	my $sth= $dbh_tests->prepare(<<END);
	    SELECT * FROM steps
		WHERE flight=$flight AND job='$j->{job}'
		ORDER BY stepno
END
        $sth->execute();

        $jobsummary .= sprintf " %-${jl}s %-${rl}s\n", $j->{job}, $j->{status};

        my $foundfail= 0;

        my $storefail= sub {
            my ($s) = @_;
            my $failkey= "$j->{job}.$s->{testid}";
            my $failval= {
                Job => $j,
                Step => $s,
            };
            $fails{$failkey}= $failval;
            return $failval;
        };

        my $gridrow= 0;

	while (my $s= $sth->fetchrow_hashref()) {
	    $jobtext .= sprintf "%2d %-${sl}s %-${rl}s\n",
	        $s->{stepno}, $s->{testid}, $s->{status};

            my $fi= { Job => $j, Step => $s };
            
            if ($s->{status} ne 'pass') {
                $fi= $storefail->($s);
                $foundfail= 1;
            }

            my $rowspec= $s->{testid};
            $rowspec =~ s/\(\d+\)$//;

            for (;;) {
                if ($s->{step} eq 'ts-logs-capture' && $gridrow < 100) {
                    $gridrow= 100;
                }
                if (!defined $gridrow_rowspec[$gridrow]) {
                    $gridrow_rowspec[$gridrow]= $rowspec;
                    last;
                }
                if ($gridrow_rowspec[$gridrow] eq $rowspec and
                    !defined $grid{ $j->{job} }[ $gridrow ]) {
                    last;
                }
                $gridrow++;
            }
            $grid{ $j->{job} }[ $gridrow ]= $fi;
	}

        if ($j->{status} ne 'pass' and !$foundfail) {
            $storefail->({
                stepno => '',
                status => "$j->{status}",
                testid => '<none executed>'
            });
        }

        my $revh= $dbh_tests->prepare(<<END);
            SELECT * FROM runvars
                WHERE flight=$flight AND job='$j->{job}'
                  AND name like 'built_revision_%'
                ORDER BY name
END
        $revh->execute();
        while (my $r= $revh->fetchrow_hashref()) {
            my $br= $r->{name};
            $br =~ s/^built_revision_// or die "$br ?";
            $jobtext .= sprintf " %-15s %-.20s\n", $br, $r->{val};
        }

	push @jobtexts, [ split /\n/, $jobtext ];
    }

    my $outcomes= join '/', sort keys %statuscounts;
    my $outcome;
    if ($outcomes eq 'pass') {
        $outcome= 'all pass';
    } elsif ($outcomes eq 'fail') {
        $outcome= 'ALL FAIL';
    } elsif ($outcomes =~ m,^(?:blocked/)?(?:fail/)?pass$,) {
        $outcome= 'FAIL';
    } else {
        $outcome= "trouble: $outcomes";
    }

    return {
        Flight => $flight,
        FlightInfo => $flightinfo,
        JobTexts => \@jobtexts,
        Failures => \%fails,
        StatusCounts => \%statuscounts,
        OutcomeSummary => $outcome,
        JobsSummary => $jobsummary,
        GridCols => \@gridcol_job,
        GridRows => \@gridrow_rowspec,
        GridGrid => \%grid
    };
}

sub printversions ($) {
    my ($thisthat) = @_;
    my ($sv) = $specver{$thisthat};
    foreach my $k (sort keys %$sv) {
        printf " %-${tl}s %s\n", $k, $sv->{$k} or die $!;
        print MRO "version $thisthat $k $sv->{$k}\n" or die $!;
    }
}

sub printout ($) {
    my ($r) = @_;
    print <<END or die $!;
$r->{Flight}: $r->{OutcomeSummary}

flight $r->{Flight} $branch $r->{FlightInfo}{blessing}
$c{ReportHtmlPubBaseUrl}/$r->{Flight}/
END
    if (defined $r->{Overall}) {
        print "\n" or die $!;
        print $r->{Overall} or die $!;
    }
    print <<END or die $!;

tests which did not succeed:
END

    foreach my $failk (sort keys %{ $r->{Failures} }) {
        my $failv= $r->{Failures}{$failk};
        my $s= $failv->{Step};
        my $j= $failv->{Job};
        my $text= (sprintf" %-${jl}s %2s %-${sl}s %-${rl}s",
                   $j->{job}, $s->{stepno}, $s->{testid}, $s->{status});
        $text .= $failv->{Summary};
        $text =~ s/ *$//;
        while (length($text) > $cw) { last unless $text =~ s/(.* ) /$1/; }
        print $text, "\n";
    }
    if (!%{ $r->{Failures} }) {
        print " none - all tests in this flight passed" or die $!;
    }
    print "\n" or die $!;

    if ($specver{this}) {
        print "version targeted for testing:\n" or die $!;
        printversions('this');
    }
    if ($specver{that}) {
        print "baseline version:\n" or die $!;
        printversions('that');
    }

    print "\njobs:\n", $r->{JobsSummary}, "\n" or die $!;

    foreach my $jt (@{ $r->{JobTexts} }) {
	print '-'x$cw or die $!;
        print "\n" or die $!;
        print join "\n", @$jt or die $!;
        print "\n" or die $!;
    }

    my $hostname= `hostname -f`;
    $? and die $?;  chomp $hostname;

    my $logs= $c{Logs};

    print <<END or die $!;

------------------------------------------------------------
sg-report-flight on $hostname
logs: $logs
images: $c{Images}

$c{ReportTrailer}
END
}

sub justifyfailures ($) {
    my ($fi) = @_;

    return unless $specver{that};

    my @failures= values %{ $fi->{Failures} };

    my $anypassq= <<END;
        SELECT * FROM flights NATURAL JOIN steps
            WHERE branch=?
              AND job=? and testid=? and status='pass'
              AND $blessingscond
            LIMIT 1
END
    $anypassq= $dbh_tests->prepare($anypassq);

    foreach my $failv (@failures) {
        my $j= $failv->{Job};
        my $s= $failv->{Step};
        my $st= $s->{status};
        print DEBUG "justifying $j->{job} $s->{testid} $st\n";

        if (!length $s->{stepno}) {
            print MRO "broken-job $j->{job} $j->{status}\n" or die $!;
            print DEBUG " broken job\n";
            $failv->{Summary}= '';
            $failv->{Blocker}= 'broken';
            next;
        }

        $anypassq->execute($branch, $j->{job}, $s->{testid}, @blessings);
        if (!$anypassq->fetchrow_hashref()) {
            print MRO "never-passed $j->{job} $s->{testid} $st\n";
            print DEBUG " never passed\n";
            $failv->{Summary}= 'never pass';
            $failv->{Blocker}= '';
            next;
        }

	if ($st eq 'blocked') {
	    print MRO "blocked $s->{job} $s->{testid}\n";
	    print DEBUG " blocked, call it justifiable\n";
	    $failv->{Summary}= 'n/a';
            $failv->{Blocker}= '';
	    next;
	}
        if ($st ne 'fail') {
            print MRO "broken $j->{job} $s->{testid} $st\n";
            print DEBUG " not a fail, unjustifiable\n";
            $failv->{Summary}= '';
            $failv->{Blocker}= 'broken';
            next;
        }

	my @rtups;
	push @rtups, [ 10, 0, "baseline untested", undef ];

	findaflight('that', sub {
            my ($chkflight) = @_;
            my $checkq= $dbh_tests->prepare(<<END);
                SELECT status FROM steps WHERE flight=? AND job=? AND testid=?
END
            $checkq->execute($chkflight, $j->{job}, $s->{testid});
            my ($chkst) = $checkq->fetchrow_array();
	    my $rtup;
	    if (!defined $chkst) {
		$rtup= [ 50, '', "blocked in", $chkflight ];
	    } elsif ($chkst eq $st) {
		$rtup= [ 190, '', "like", $chkflight ];
	    } elsif ($chkst eq 'fail') {
		$rtup= [ 180, '', "failed in", $chkflight ];
	    } elsif ($chkst eq 'pass') {
		$rtup= [ 100, 'regression', "REGR. vs.", $chkflight ];
	    } else {
		$rtup= [ 170, '', "$chkst in", $chkflight ];
	    }
	    push @rtups, $rtup;
	    return $rtup->[2];
        });
	@rtups= sort { $b->[0] <=> $a->[0] } @rtups;
	$failv->{Blocker}= $rtups[0][1];
	$failv->{SummaryCore}= $rtups[0][2];
	$failv->{SummaryRefFlight}= $rtups[0][3];
	$failv->{Summary}= $failv->{SummaryCore};
        $failv->{Summary}.= $failv->{SummaryRefFlight}
            if defined $failv->{SummaryRefFlight};
	print DEBUG " so $failv->{Summary}\n";
        print DEBUG " blocker $failv->{Blocker}\n" if $failv->{Blocker};
        if ($failv->{Blocker} eq 'regression') {
            print MRO "regression $j->{job} $s->{testid}\n" or die $!;
            next;
        }
    }
    if (!@failures) {
        print MRO "tolerable\nperfect\n" or die $!;
         $fi->{Overall}.= "Perfect :-)\n";
    } elsif (grep { $_->{Blocker} eq 'regression' } @failures) {
        $fi->{OutcomeSummary}= "regressions - $fi->{OutcomeSummary}";
        $fi->{Overall}.= "Regressions :-(\n";
    } elsif (!grep { $_->{Blocker} } @failures) {
        $fi->{OutcomeSummary}= "tolerable $fi->{OutcomeSummary}";
        print MRO "tolerable\n" or die $!;
        $fi->{Overall}.= "Failures :-/ but no regressions.\n";
    } else {
        $fi->{Overall}.= "Failures and problems with tests :-(\n";
    }
}

sub htmlout ($) {
    my ($fi) = @_;
    return unless defined $htmlout;

    open H, "> $htmlout.new" or die "$htmlout.new $!";
    print H <<END;
<html><head><title>Report on flight $fi->{Flight}</title><head>
<body>
<table rules=all>
END
    print H "<tr><td></td>\n";
    my $colmap= sub {
        local ($_) = @_;
        s/^(\w+)\-.*\-(\w+)$/$1 $2 $&/;
        return $_;
    };
    my @cols= sort { $colmap->($a) cmp $colmap->($b) } @{ $fi->{GridCols} };
    foreach my $col (@cols) {
        my $th= $col;
        $th =~ s/\-/ $&/g;
        print H "<th>";
        print H "<a href=\"".encode_entities($col)."/\">";
        print H encode_entities($th);
        print H "</a>";
        print H "</th>";
    }
    print H "\n";
    foreach my $rowix (0..$#{ $fi->{GridRows} }) {
        next unless $fi->{GridRows}[$rowix];
        print H "<tr><th>",encode_entities($fi->{GridRows}[$rowix]),"</th>";
        foreach my $col (@cols) {
            my $ei= $fi->{GridGrid}{$col}[$rowix];
            print H "<td";
            if ($ei) {
                my $s= $ei->{Step};
                my $sum_core= $ei->{SummaryCore};
                my $sum_flight= $ei->{SummaryRefFlight};
                $sum_core= $ei->{Summary} if !defined $sum_core;
                my $bgc;
                if (!defined $sum_core || !length $sum_core) {
                    $sum_core= $s->{status};
                    $bgc= $sum_core eq 'pass' ? '#008800' :
                          $sum_core eq 'fail' ? '#ff8888' :
                                                '#ffff00';
                } else {
                    $bgc= $ei->{Blocker} eq 'regression'
                        ? '#ff8888' : '#ffff00';
                }
                print H " bgcolor=\"$bgc\">";
                print H "<a href=\"".encode_entities($col).
                    "/$s->{stepno}.".encode_entities($s->{step}).".log\">";
                #print H "[$s->{stepno}] ";
                print H encode_entities($sum_core);
                print H "</a>";
                if (defined $sum_flight) {
                    print H " <a href=\"../$sum_flight/\">$sum_flight</a>";
                }
            } else {
                print H " bgcolor=\"#444444\">";
            }
            print H "</td>";
        }
        print H "\n";
    }
    print H "</table>";

    my %vercols;
    foreach my $tt (qw(this that)) {
        my $ary= $specver{$tt};
        next unless $ary;
        $vercols{$_}=1 foreach keys %$ary;
    }
    my @vercols= sort keys %vercols;
    if (@vercols) {
        print H "<h2>targeted versions</h2>\n";
        print H "<table rules=all>";
        print H "<tr><td></td>";
        print H "<th>".encode_entities($_)."</th>" foreach @vercols;
        foreach my $tt (qw(this that)) {
            my $ary= $specver{$tt};
            next unless $ary;
            print H "<tr>";
            print H "<th>".($tt eq 'that' ? 'baseline' : $tt)."</th>";
            foreach my $vc (@vercols) {
                my $v= $ary->{$vc};
                print H "<td>";
                print H encode_entities($v) if defined $v;
                print H "</td>";
            }
        }
        print H "</table>";
    }
    print H "</body></html>";
    H->error and die $!;
    close H or die $!;
    rename "$htmlout.new", $htmlout or die $!;
}

findspecflight();
my $fi= examineflight($specflight);
justifyfailures($fi);
printout($fi);
htmlout($fi);

if (defined $mro) {
    close MRO or die $!;
    rename "$mro.new",$mro or die $!;
}
