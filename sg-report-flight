#!/usr/bin/perl -w

use strict qw(refs vars);

use DBI;
use Osstest;
use IO::Handle;

our $specflight;
our %specver;
our @blessings;
our $mro;
our $branch;

open DEBUG, ">/dev/null";
open MRO, ">/dev/null";

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--?$/;
    if (m/^--(this|that)-([^=]+)\=([^=]+)$/) {
        $specver{$1}{$2}= $3;
    } elsif (m/^--machine-readable-output=(.*)$/) {
        $mro= $1;
        open MRO, "> $mro.new" or die "$mro.new $!";
    } elsif (m/^--blessings?=(.*)$/) {
        push @blessings, split ',', $1;
    } elsif (m/^--debug/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
        die "$_ ?";
    }
}

@ARGV==1 or die;

$_= shift @ARGV;
if (m/^\d+$/) {
    $specflight= $_;
} else {
    $branch= $_;
}

push @blessings, 'real' unless @blessings;

csreadconfig();

# formatting settings
our $jl= 28;
our $sl= 28;
our $rl= 9;
our $cw= 79;
our $tl= 20;

our $blessingscond= '('.join(' OR ', map { "blessing=?" } @blessings).')';

sub findaflight ($$) {
    my ($thisthat, $sub) = @_;

    die $thisthat unless keys %{ $specver{$thisthat} };

    my $flightsq= <<END;
        SELECT flight FROM flights
            WHERE branch=?
              AND $blessingscond
            ORDER BY flight DESC
            LIMIT 1000
END
    #print DEBUG "===\n$flightsq\n===\n";
    $flightsq= $dbh_tests->prepare($flightsq);
    $flightsq->execute($branch, @blessings);

    my $revisionsq= <<END;
            SELECT job, val FROM runvars
                WHERE flight=?
		  AND name=?
		GROUP BY job, val
END
    #print DEBUG "===\n$mismatchq\n===\n";
    $revisionsq= $dbh_tests->prepare($revisionsq);

    while (my ($tflight) = $flightsq->fetchrow_array) {
	my $whynot;
	foreach my $tree (keys %{ $specver{$thisthat} }) {
	    my $v= $specver{$thisthat}{$tree};
	    $revisionsq->execute($tflight, "built_revision_$tree");
	    my $revisions= $revisionsq->fetchall_arrayref({});
	    if (!@$revisions) {
		$whynot= "no built $tree";
		last;
	    }
	    my ($wrong) = grep {
		$_->{val} !~ m/^(?: .*: )? $v /x;
	    } @$revisions;

	    if (defined $wrong) {
		$whynot= "mismatch $tree $wrong->{job} $wrong->{val} != $v";
		last;
	    }
	}
        $whynot= $sub->($tflight) if !defined $whynot;
        return $flight            if !defined $whynot;
        print DEBUG " $tflight $whynot\n";
    }
    return undef;
}

sub findspecflight () {
    if (defined $specflight) {
        ($branch) = $dbh_tests->selectrow_array(<<END, {}, $specflight);
            SELECT branch FROM flights WHERE flight=?
END
        die "$flight branch ?" unless defined $branch;
    } else {
        $specflight= findaflight('this', sub { return undef; });
        die unless defined $specflight;
    }
}

sub examineflight ($) {
    my ($flight) = @_;
    my @jobtexts;
    my %fails;
    my %statuscounts;
    my $jobsummary= '';
    
    my $flightinfo= $dbh_tests->selectrow_hashref(<<END);
        SELECT * FROM flights
            WHERE flight=$flight
END

    my $jobs= $dbh_tests->selectall_arrayref(<<END, { Slice => {} });
        SELECT * FROM jobs
            WHERE flight=$flight
            ORDER BY job
END

    foreach my $j (@$jobs) {
	$statuscounts{$j->{status}}++;

	my $jobtext= sprintf "%s:\n", $j->{job};

	my $sth= $dbh_tests->prepare(<<END);
	    SELECT * FROM steps
		WHERE flight=$flight AND job='$j->{job}'
		ORDER BY stepno
END
        $sth->execute();

        $jobsummary .= sprintf " %-${jl}s %-${rl}s\n", $j->{job}, $j->{status};

        my $foundfail= 0;

        my $storefail= sub {
            my ($s) = @_;
            my $failkey= "$j->{job}.$s->{testid}";
            my $failval= {
                Job => $j,
                Step => $s,
            };
            $fails{$failkey}= $failval;
        };

	while (my $s= $sth->fetchrow_hashref()) {
	    $jobtext .= sprintf "%2d %-${sl}s %-${rl}s\n",
	        $s->{stepno}, $s->{testid}, $s->{status};
            if ($s->{status} ne 'pass') {
                $storefail->($s);
                $foundfail= 1;
            }
	}

        if ($j->{status} ne 'pass' and !$foundfail) {
            $storefail->({
                stepno => '',
                status => "$j->{status}",
                testid => '<none executed>'
            });
        }

        my $revh= $dbh_tests->prepare(<<END);
            SELECT * FROM runvars
                WHERE flight=$flight AND job='$j->{job}'
                  AND name like 'built_revision_%'
                ORDER BY name
END
        $revh->execute();
        while (my $r= $revh->fetchrow_hashref()) {
            my $br= $r->{name};
            $br =~ s/^built_revision_// or die "$br ?";
            $jobtext .= sprintf " %-15s %-.20s\n", $br, $r->{val};
        }

	push @jobtexts, [ split /\n/, $jobtext ];
    }

    my $outcomes= join '/', sort keys %statuscounts;
    my $outcome;
    if ($outcomes eq 'pass') {
        $outcome= 'all pass';
    } elsif ($outcomes eq 'fail') {
        $outcome= 'ALL FAIL';
    } elsif ($outcomes =~ m,^(?:blocked/)?(?:fail/)?pass$,) {
        $outcome= 'FAIL';
    } else {
        $outcome= "trouble: $outcomes";
    }

    return {
        Flight => $flight,
        FlightInfo => $flightinfo,
        JobTexts => \@jobtexts,
        Failures => \%fails,
        StatusCounts => \%statuscounts,
        OutcomeSummary => $outcome,
        JobsSummary => $jobsummary,
    };
}

sub printversions ($) {
    my ($thisthat) = @_;
    my ($sv) = $specver{$thisthat};
    foreach my $k (sort keys %$sv) {
        printf " %-${tl}s %s\n", $k, $sv->{$k} or die $!;
        print MRO "version $thisthat $k $sv->{$k}\n" or die $!;
    }
}

sub printout ($) {
    my ($r) = @_;
    print <<END or die $!;
oss xen test $r->{Flight}: $r->{OutcomeSummary}

flight $r->{Flight} $branch $r->{FlightInfo}{blessing}
END
    if (defined $r->{Overall}) {
        print "\n" or die $!;
        print $r->{Overall} or die $!;
    }
    print <<END or die $!;

tests which did not succeed:
END

    foreach my $failk (sort keys %{ $r->{Failures} }) {
        my $failv= $r->{Failures}{$failk};
        my $s= $failv->{Step};
        my $j= $failv->{Job};
        my $text= (sprintf" %-${jl}s %2s %-${sl}s %-${rl}s",
                   $j->{job}, $s->{stepno}, $s->{testid}, $s->{status});
        $text .= $failv->{Summary};
        $text =~ s/ *$//;
        while (length($text) > $cw) { last unless $text =~ s/(.* ) /$1/; }
        print $text, "\n";
    }
    if (!%{ $r->{Failures} }) {
        print " none - all tests in this flight passed" or die $!;
    }
    print "\n" or die $!;

    if ($specver{this}) {
        print "version targeted for testing:\n" or die $!;
        printversions('this');
    }
    if ($specver{that}) {
        print "baseline version:\n" or die $!;
        printversions('that');
        print <<'END' or die $!;
(Individual test failures are shown as REGRESSION above if they never failed
in the baseline.  If they did, a flight in which they failed is shown.
"never pass" indicates that this test has never passed on this branch.)
END
    }

    print "\njobs:\n", $r->{JobsSummary}, "\n" or die $!;

    foreach my $jt (@{ $r->{JobTexts} }) {
	print '-'x$cw or die $!;
        print "\n" or die $!;
        print join "\n", @$jt or die $!;
        print "\n" or die $!;
    }

    my $hostname= `hostname -f`;
    $? and die $?;  chomp $hostname;

    my $logs= $c{Logs};

    print <<END or die $!;

------------------------------------------------------------
sg-report-flight on $hostname
logs: $logs
stash: $c{Stash}
images: $c{Images}

$c{ReportTrailer}
END
}

sub justifyfailures ($) {
    my ($fi) = @_;

    return unless $specver{that};

    my @failures= values %{ $fi->{Failures} };

    my $anypassq= <<END;
        SELECT * FROM flights NATURAL JOIN steps
            WHERE branch=?
              AND job=? and testid=? and status='pass'
              AND $blessingscond
            LIMIT 1
END
    $anypassq= $dbh_tests->prepare($anypassq);

    foreach my $failv (@failures) {
        my $j= $failv->{Job};
        my $s= $failv->{Step};
        my $st= $s->{status};
        print DEBUG "justifying $j->{job} $s->{testid} $st\n";

        if (!length $s->{stepno}) {
            print MRO "broken-job $j->{job} $j->{status}\n" or die $!;
            print DEBUG " broken job\n";
            $failv->{Summary}= '';
            $failv->{Blocker}= 'broken';
            next;
        }

        $anypassq->execute($branch, $j->{job}, $s->{testid}, @blessings);
        if (!$anypassq->fetchrow_hashref()) {
            print MRO "never-passed $j->{job} $s->{testid} $st\n";
            print DEBUG " never passed\n";
            $failv->{Summary}= 'never pass';
            $failv->{Blocker}= '';
            next;
        }

	if ($st eq 'blocked') {
	    print MRO "blocked $s->{job} $s->{testid}\n";
	    print DEBUG " blocked, call it justifiable\n";
	    $failv->{Summary}= 'n/a';
            $failv->{Blocker}= '';
	    next;
	}
        if ($st ne 'fail') {
            print MRO "broken $j->{job} $s->{testid} $st\n";
            print DEBUG " not a fail, unjustifiable\n";
            $failv->{Summary}= '';
            $failv->{Blocker}= 'broken';
            next;
        }

	my @rtups;
	push @rtups, [ 10, 0, "baseline untested" ];

	findaflight('that', sub {
            my ($chkflight) = @_;
            my $checkq= $dbh_tests->prepare(<<END);
                SELECT status FROM steps WHERE flight=? AND job=? AND testid=?
END
            $checkq->execute($chkflight, $j->{job}, $s->{testid});
            my ($chkst) = $checkq->fetchrow_array();
	    my $rtup;
	    if (!defined $chkst) {
		$rtup= [ 50, '', "blocked in $chkflight" ];
	    } elsif ($chkst eq $st) {
		$rtup= [ 190, '', "like $chkflight" ];
	    } elsif ($chkst eq 'fail') {
		$rtup= [ 180, '', "failed in $chkflight" ];
	    } elsif ($chkst eq 'pass') {
		$rtup= [ 100, 'regression', "REGR. vs. $chkflight" ];
	    } else {
		$rtup= [ 170, '', "$chkst in $chkflight" ];
	    }
	    push @rtups, $rtup;
	    return $rtup->[2];
        });
	@rtups= sort { $a->[0] <=> $b->[0] } @rtups;
	$failv->{Blocker}= $rtups[0][1];
	$failv->{Summary}= $rtups[0][2];
	print DEBUG " so $failv->{Summary}\n";
        print DEBUG " blocker $failv->{Blocker}\n" if $failv->{Blocker};
        if ($failv->{Blocker} eq 'regression') {
            print MRO "regression $j->{job} $s->{testid}\n" or die $!;
            next;
        }
    }
    if (!@failures) {
        print MRO "tolerable\nperfect\n" or die $!;
         $fi->{Overall}.= "Perfect :-)\n";
    } elsif (grep { $_->{Blocker} eq 'regression' } @failures) {
        $fi->{OutcomeSummary}= "regressions - $fi->{OutcomeSummary}";
        $fi->{Overall}.= "Regressions :-(\n";
    } elsif (!grep { $_->{Blocker} } @failures) {
        $fi->{OutcomeSummary}= "tolerable $fi->{OutcomeSummary}";
        print MRO "tolerable\n" or die $!;
        $fi->{Overall}.= "Failures :-/ but no regressions.\n";
    } else {
        $fi->{Overall}.= "Failures and problems with tests :-(\n";
    }
}

findspecflight();
my $fi= examineflight($specflight);
justifyfailures($fi);
printout($fi);

if (defined $mro) {
    close MRO or die $!;
    rename "$mro.new",$mro or die $!;
}
