#!/usr/bin/perl -w

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


use strict qw(refs vars);

use DBI;
use Osstest;
use IO::Handle;
use HTML::Entities;
use URI::Escape;
use POSIX;
use IPC::Open2;
use Data::Dumper;
use File::Path;

use Osstest;
use Osstest::Executive;

our $specflight;
our %specver;
our (@blessings, @branches_also);
our $mro;
our $htmldir;
our ($branch, $branches_cond_q);
our @allows;
our (@includebeginfiles,@includefiles);

open DEBUG, ">/dev/null";
open MRO, ">/dev/null";

our $maxflight;

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--?$/;
    if (m/^--(this|that)-([^=]+)\=([^=]+)$/) {
        $specver{$1}{$2}= $3;
    } elsif (m/^--machine-readable-output=(.*)$/) {
        $mro= $1;
        open MRO, "> $mro.new" or die "$mro.new $!";
    } elsif (m/^--html-dir=(.*)$/) {
        $htmldir= $1;
    } elsif (m/^--blessings?=(.*)$/) {
        push @blessings, split ',', $1;
    } elsif (m/^--branches-also?=(.*)$/) {
        push @branches_also, split ',', $1;
    } elsif (m/^--include-begin=(.*)$/) {
        push @includebeginfiles, $1;
    } elsif (m/^--include=(.*)$/) {
        push @includefiles, $1;
    } elsif (m/^--max-flight=(\d+)$/) {
        $maxflight= $1;
    } elsif (m/^--allow=(.*)$/) {
        my ($allowfile) = $1;
        if (!open A, '<', $allowfile) {
            die "$allowfile: $!" unless $! == &ENOENT;
        } else {
            while (<A>) {
                s/^\s+//; s/\s+$// or die;
                next unless m/\S/;
                next if m/^\#/;
                s/\s+/ /g;
		my $remove = s/^!\s*//;
                die if m/ /g > 1;
                $_ .= ' @@' unless m/ /;
                s/\@\@/ '[^ ]*' /ge;
                s/\@/ '[^ -\/]*' /ge;
                $_= '^(?:'.$_.')$';
		my $entry = $_;
                if (!$remove) {
		    print DEBUG "ALLOW $entry\n";
		    push @allows, $entry;
		} else {
		    print DEBUG "DEALLOW $entry\n";
		    @allows = grep { $_ ne $entry } @allows;
		}
            }
            A->error and die "$allowfile $!";
            close A or die "$allowfile $!";
        }
    } elsif (m/^--debug/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
        die "$_ ?";
    }
}

@ARGV==1 or die;

$_= shift @ARGV;
if (m/^\d+$/) {
    $specflight= $_;
} else {
    $branch= $_;
}

die if defined $specver{this}{flight};
die if defined $specver{that}{flight} &&
    grep { $_ ne 'flight' } keys %{ $specver{that} };

push @blessings, 'real', 'real-bisect' unless @blessings;

csreadconfig();

# formatting settings
our $jl= 28;
our $sl= 28;
our $rl= 8;
our $cw= 79;
our $tl= 20;
our $htmlleaf= "info.html";

our $blessingscond= '('.join(' OR ', map { "blessing=?" } @blessings).')';

if (defined $maxflight) {
    $blessingscond= "( flight <= $maxflight AND $blessingscond )";
}

sub displayflightnum ($) {
    my ($flight) = @_;
    my $frow = $dbh_tests->selectrow_hashref
	("SELECT * FROM flights WHERE flight = ?", {}, $flight);
    if ($frow && $frow->{blessing} =~ m/-.*/) {
	return "$flight$&";
    } else {
	return $flight;
    }
}

sub compute_branches_cond () {
    $branches_cond_q = "(".(join ' OR ',
			    map { "branch='$_'" }
			    ($branch, @branches_also)).")";
}

sub findaflight ($$$$$) {
    my ($thisthat, $exceptflight, $job, $testid, $sub) = @_;

    print DEBUG "FINDAFLIGHT $thisthat";
    print DEBUG " !$exceptflight" if defined $exceptflight;
    print DEBUG " $job.$testid" if defined $job;
    print DEBUG "\n";        

    if (!keys %{ $specver{$thisthat} }) {
        print DEBUG " unspecified\n";
        return undef;
    }

    my $checkq= db_prepare(<<END);
        SELECT status FROM steps WHERE flight=? AND job=? AND testid=?
END

    my $thatflight= $specver{that}{flight};
    if (defined $thatflight) {
        print DEBUG " $thatflight specified:\n";
        $checkq->execute($thatflight, $job, $testid);
        my ($chkst) = $checkq->fetchrow_array();
        my $whynot= $sub->($thatflight, $chkst);
        return $thatflight if !defined $whynot;
        print DEBUG " $thatflight $whynot\n";
        return undef;
    }

    my @flightsq_params;
    my $flightsq_jobcond='TRUE';
    if (defined $job) {
	push @flightsq_params, $job;
	$flightsq_jobcond = <<END;
                  EXISTS (SELECT 1
			    FROM jobs
			   WHERE jobs.flight = flights.flight
			     AND jobs.job = ?)
END
    }

    my $flightsq= <<END;
      SELECT * FROM (
        SELECT flight, blessing FROM flights
            WHERE $branches_cond_q
              AND $flightsq_jobcond
              AND $blessingscond
            ORDER BY flight DESC
            LIMIT 1000
      ) AS sub
      ORDER BY blessing ASC, flight DESC
END
    $flightsq= db_prepare($flightsq);
    $flightsq->execute(@flightsq_params, @blessings);

    my $buildflightsq= db_prepare(<<END);
        SELECT val FROM runvars
	 WHERE flight = ?
           AND name LIKE '%buildjob'
END

    my $revisionsq= <<END;
            SELECT flight, job, val FROM runvars
                WHERE flight=?
		  AND name=?
		GROUP BY flight, job, val
END
    $revisionsq= db_prepare($revisionsq);

    my $revisionsosstestq= db_prepare(<<END);
            SELECT harness AS val FROM flights_harness_touched
                WHERE flight=?
END

    while (my ($tflight) = $flightsq->fetchrow_array) {
	my @bflights;
	push @bflights, $tflight;
	$buildflightsq->execute($tflight);
	while (my $bflightrow = $buildflightsq->fetchrow_hashref()) {
	    my $val = $bflightrow->{val};
	    next unless $val =~ m/\./; # same flight, already added
	    push @bflights, $`;
	}
	my $whynot;
	foreach my $tree (keys %{ $specver{$thisthat} }) {
	    my @revisions;
	    my $v= $specver{$thisthat}{$tree};
	    foreach my $bflight (@bflights) {
		my $revisions;
		if ($tree ne 'osstest') {
		    $revisionsq->execute($bflight, "built_revision_$tree");
		    $revisions= $revisionsq->fetchall_arrayref({});
		} else {
		    $revisionsosstestq->execute($bflight);
		    $revisions= $revisionsosstestq->fetchall_arrayref({});
		}
		push @revisions, @$revisions;
	    }
            if (!@revisions) {
                $whynot= "no built/used $tree";
                last;
            }
            my ($wrong) = grep {
                $_->{val} !~ m/^(?: .*: )? $v /x;
            } @revisions;

            if (defined $wrong) {
                $whynot= "mismatch $tree ".
                    (defined $wrong->{job} ?
		     "$wrong->{flight}.$wrong->{job}" : "(osstest)").
                    " $wrong->{val} != $v";
                last;
            }
	}

        if (!defined $whynot &&
            defined $exceptflight && $tflight==$exceptflight) {
            $whynot= "flight in question";
        }
        my $chkst;
        if (!defined $whynot && defined $job) {
            $checkq->execute($tflight, $job, $testid);
            ($chkst) = $checkq->fetchrow_array();
        }
        $whynot= $sub->($tflight, $chkst) if !defined $whynot;
        if (!defined $whynot) {
            print DEBUG " $tflight FOUND\n";
            return $tflight;
        }
        print DEBUG " $tflight $whynot\n";
    }
    return undef;
}

sub findspecflight () {
    if (defined $specflight) {
        ($branch) = $dbh_tests->selectrow_array(<<END, {}, $specflight);
            SELECT branch FROM flights WHERE flight=?
END
        die "$specflight branch ?" unless defined $branch;
	compute_branches_cond();
    } else {
	compute_branches_cond();
        $specflight= findaflight('this', undef,undef,undef,
                                 sub { return undef; });
        die unless defined $specflight;
    }
}

sub examineflight ($) {
    my ($flight) = @_;
    my @jobtexts;
    my %fails;
    my %statuscounts;
    my $jobsummary= '';

    my @gridcol_job;
    my @gridrow_rowspec;
    my %grid;

    my $flightinfo= $dbh_tests->selectrow_hashref(<<END);
        SELECT * FROM flights
            WHERE flight=$flight
END

    my $jobs= $dbh_tests->selectall_arrayref(<<END, { Slice => {} });
        SELECT * FROM jobs
            WHERE flight=$flight
END

    my $colmap= sub {
        local ($_) = @_;
        $_= $_->{job};
        #printf STDERR "CM %40s | ", $_;
        s#\bx\w+$#_$&#;
        s#^(\w+)\-(.*)$# $1.' '.(join '-', reverse split /-/, $2).' '. $& #e;
        #printf STDERR " %40s\n", $_;
        return $_;
    };
    $jobs= [ sort { $colmap->($a) cmp $colmap->($b) } @$jobs ];

    my $stepsq= db_prepare(<<END);
        SELECT * FROM steps
            WHERE flight=$flight AND job=?
            ORDER BY stepno
END

    my %jobtestid2rowspec;

    my ($tsout,$tsin);
    my $tsortpid = open2($tsout, $tsin, 'tsort');
    defined $tsortpid or die $!;
    foreach my $j (@$jobs) {
        my $lasttid;

        my $id2spec= $jobtestid2rowspec{$j->{job}}= { };

        my %rowspeccounts;
        my $testid2rowspec= sub {
            my ($testid) = @_;
            my $rowspec= $testid;
            $rowspec =~ s/\(\d+\)$//;
            my $count= ++$rowspeccounts{$rowspec};
            $rowspec .= "[$count]" if $count>1;
            $id2spec->{$testid}= $rowspec;
            return $rowspec;
        };

        $stepsq->execute($j->{job});
        while (my $s= $stepsq->fetchrow_hashref()) {
            my $tid= $s->{testid};
            my $ref= $testid2rowspec->($tid);
            print $tsin "R$ref T$tid\n" or die $!;
            if (defined $lasttid) {
                print $tsin "T$lasttid T$tid\n" or die $!;
                print $tsin "T$lasttid R$ref\n" or die $!;
            }
            $lasttid= $tid;
        }
    }
    close $tsin or die $!;
    my $ts_gridrow= 0;
    my %ts_gridrow;
    for (;;) {
        my $item = <$tsout>;
        last unless defined $item;
        die unless chomp $item;
        next unless $item =~ s/^R//;
        $ts_gridrow{$item}= ++$ts_gridrow;
    }
    $tsout->error and die $!;
    close $tsout or die $!;
    waitpid $tsortpid, 0 or die $!;
    $? and die "tsort $?";

    foreach my $j (@$jobs) {
        push @gridcol_job, $j->{job};

	$statuscounts{$j->{status}}++;

	my $jobtext= sprintf "%s:\n", $j->{job};

        $stepsq->execute($j->{job});

        $jobsummary .= sprintf " %-60s %-${rl}s\n", $j->{job}, $j->{status};

        my $foundfail= 0;

        my $storefail= sub {
            my ($s) = @_;
            my $failkey= "$j->{job}.$s->{testid}";
            my $failval= {
                Flight, => $flight,
                Job => $j,
                Step => $s,
            };
            $fails{$failkey}= $failval;
            return $failval;
        };

        my $gridrow= 0;

	while (my $s= $stepsq->fetchrow_hashref()) {
	    $jobtext .= sprintf "%2d %-${sl}s %-${rl}s\n",
	        $s->{stepno}, $s->{testid}, $s->{status};

            my $fi= { Job => $j, Step => $s };
            
            if ($s->{status} ne 'pass') {
                $fi= $storefail->($s);
                $foundfail= 1;
            }

            my $rowspec= $jobtestid2rowspec{$j->{job}}{$s->{testid}};

            my $mingridrow= $ts_gridrow{$rowspec};
            if ($s->{step} eq 'ts-logs-capture' && $mingridrow < 100) {
                  $mingridrow += 100;
              }
            $gridrow= $mingridrow if $gridrow < $mingridrow;

            for (;;) {
                if (!defined $gridrow_rowspec[$gridrow]) {
                    $gridrow_rowspec[$gridrow]= $rowspec;
                    last;
                }
                if ($gridrow_rowspec[$gridrow] eq $rowspec and
                    !defined $grid{ $j->{job} }[ $gridrow ]) {
                    last;
                }
                $gridrow++;
            }
            $grid{ $j->{job} }[ $gridrow ]= $fi;
	}

        if ($j->{status} ne 'pass' and !$foundfail) {
            $storefail->({
                stepno => '',
                status => "$j->{status}",
                testid => '<none executed>'
            });
        }

        my $revh= db_prepare(<<END);
            SELECT * FROM runvars
                WHERE flight=$flight AND job='$j->{job}'
                  AND name like 'built_revision_%'
                ORDER BY name
END
        $revh->execute();
        while (my $r= $revh->fetchrow_hashref()) {
            my $br= $r->{name};
            $br =~ s/^built_revision_// or die "$br ?";
            $jobtext .= sprintf " %-15s %-.20s\n", $br, $r->{val};
        }

	push @jobtexts, [ split /\n/, $jobtext ];
    }

    my $outcomes= join '/', sort keys %statuscounts;
    my $outcome;
    if ($outcomes eq 'pass') {
        $outcome= 'all pass';
    } elsif ($outcomes eq 'fail') {
        $outcome= 'ALL FAIL';
    } elsif ($outcomes =~ m,^(?:blocked/)?(?:fail/)?pass$,) {
        $outcome= 'FAIL';
    } else {
        $outcome= "trouble: $outcomes";
    }

    return {
        Flight => $flight,
        FlightInfo => $flightinfo,
        JobTexts => \@jobtexts,
        Failures => \%fails,
        StatusCounts => \%statuscounts,
        OutcomeSummary => $outcome,
        JobsSummary => $jobsummary,
        GridCols => \@gridcol_job,
        GridRows => \@gridrow_rowspec,
        GridGrid => \%grid
    };
}

sub printversions ($) {
    my ($thisthat) = @_;
    my ($sv) = $specver{$thisthat};
    foreach my $k (sort keys %$sv) {
        printf " %-${tl}s %s\n", $k, $sv->{$k} or die $!;
        print MRO "version $thisthat $k $sv->{$k}\n" or die $!;
    }
}

sub printout {
    my ($r, @failures) = @_;
    print <<END or die $!;
$r->{Flight}: $r->{OutcomeSummary}

END
    foreach my $include (@includebeginfiles) {
        STDOUT->flush();
        system_checked('cat','--',$include);
    }
    print <<END or die $!;
flight $r->{Flight} $branch $r->{FlightInfo}{blessing} [$r->{FlightInfo}{intended}]
$c{ReportHtmlPubBaseUrl}/$r->{Flight}/
END
    if (defined $r->{Overall}) {
        print "\n" or die $!;
        print $r->{Overall} or die $!;
    }

    my %notsucceeds;
    my %heisenreported_jobstep;
    foreach my $failv (@failures) {
        my $s= $failv->{Step};
        my $j= $failv->{Job};

        my $cat;
        my $heisenflightp= $failv->{Flight} != $specflight;
        print DEBUG "PRINTOUT ",Dumper($failv);
        if (!keys %{ $specver{that} }) {
            $cat= "A Tests which did not succeed,\n".
"including tests which could not be run:";
        } elsif ($failv->{Blocker}) {
            $cat= "A Tests which did not succeed and are blocking,\n".
"including tests which could not be run:";
        } elsif ($failv->{Heisen}) {
            $cat= "K Tests which are failing intermittently (not blocking):";
        } elsif ($failv->{Allow}) {
            $cat= "M ".
"Regressions which are regarded as allowable (not blocking):";
        } else {
            $cat= "P ".
"Tests which did not succeed, but are not blocking:";
        }
        my $heisencat= \$heisenreported_jobstep{"$j->{job} $s->{testid}"};
        next if defined $$heisencat && $$heisencat ge $cat;
        $$heisencat= $cat;

        my $text= (sprintf" %-${jl}s %2s %-${sl}s %-${rl}s ",
                   $j->{job}, $s->{stepno}, $s->{testid}, $s->{status});
	my $xstatus = '';
        $xstatus .= "in $failv->{Flight} " if $heisenflightp;
        $xstatus .= $failv->{Summary} if defined $failv->{Summary};
	$text .= $xstatus;
        $text =~ s/ *$//;
        while (length($text) > $cw) { last unless $text =~ s/(.* ) /$1/; }

	push @{ $notsucceeds{$cat} }, [ "$s->{status} $xstatus", $text ];
    }
    foreach my $cat (sort keys %notsucceeds) {
        $cat =~ m/^\w+ / or die;
        print "\n$'\n" or die $!;
	foreach (sort { $a->[0] cmp $b->[0] } @{ $notsucceeds{$cat} }) {
	    print $_->[1], "\n" or die $!;
	}
    }

    if (!%{ $r->{Failures} }) {
        print "All tests in this flight passed" or die $!;
    }
    print "\n" or die $!;

    if (keys %{ $specver{this} }) {
        print "version targeted for testing:\n" or die $!;
        printversions('this');
    }
    if (keys %{ $specver{that} }) {
        print "baseline version:\n" or die $!;
        printversions('that');
    }

    if (@includefiles) {
        print "\n","-"x60, "\n" or die $!;
    }
    foreach my $include (@includefiles) {
        STDOUT->flush();
        system_checked('cat','--',$include);
        print "-"x60, "\n" or die $!;
    }

    print "\njobs:\n", $r->{JobsSummary}, "\n" or die $!;

#    foreach my $jt (@{ $r->{JobTexts} }) {
#	print '-'x$cw or die $!;
#        print "\n" or die $!;
#        print join "\n", @$jt or die $!;
#        print "\n" or die $!;
#    }

    my $hostname= `hostname -f`;
    $? and die $?;  chomp $hostname;

    my $logs= $c{Logs};

    print <<END or die $!;

------------------------------------------------------------
sg-report-flight on $hostname
logs: $logs
images: $c{Images}

$c{ReportTrailer}
END
}

our %heisenjustified;

sub justifyfailures ($;$);
sub justifyfailures ($;$) {
    my ($fi, $heisen_why) = @_;

    print MRO "flight $fi->{Flight}\n" or die $!;

    my @failures= values %{ $fi->{Failures} };

    my $anypassq= <<END;
        SELECT * FROM flights JOIN steps USING (flight)
            WHERE $branches_cond_q
              AND job=? and testid=? and status='pass'
              AND $blessingscond
            LIMIT 1
END
    $anypassq= db_prepare($anypassq);

    my $duration_estimator= duration_estimator($branch, $blessings[0]);
    foreach my $failv (@failures) {
        my ($est) = $duration_estimator->($failv->{Job}{job},'','');
        if (!defined $est) { $est = 1e5; }
        print DEBUG "DE $failv->{Job}{job} $est\n";
        $failv->{DurationEstimate}= $est;
    }

    @failures= sort { $a->{DurationEstimate} <=> $b->{DurationEstimate} }
        @failures;

    my @heisenflights;

    foreach my $failv (@failures) {
        my $j= $failv->{Job};
        my $s= $failv->{Step};
        my $st= $s->{status};
        print DEBUG "justifying $j->{job} $s->{testid} $st\n";

        if (!length $s->{stepno}) {
            print MRO "broken-job $j->{job} $j->{status}\n" or die $!;
            print DEBUG " broken job\n";
            $failv->{Summary}= '';
            $failv->{Blocker}= 'broken';
            next;
        }

	if ($st eq 'blocked') {
	    print MRO "blocked $s->{job} $s->{testid}\n";
	    print DEBUG " blocked, call it justifiable\n";
	    $failv->{Summary}= 'n/a';
            $failv->{Blocker}= '';
	    next;
	}

	if ($st eq 'broken' && !$heisen_why) {
	    print MRO "broken-step $s->{job} $s->{testid}\n";
	}

	if ($st eq 'running') {
	    print MRO "running $j->{job} $s->{testid}\n";
	    print DEBUG " running, unjustifiable\n";
	    $failv->{Summary}= '';
	    $failv->{Blocker}= 'unfinished';
	    next;
	}

        if (!($st eq 'fail' or $st eq 'broken')) {
            print MRO "broken $j->{job} $s->{testid} $st\n";
            print DEBUG " not a fail, unjustifiable\n";
            $failv->{Summary}= "[st=$st!]";
            $failv->{Blocker}= 'broken';
            next;
        }

        $anypassq->execute($j->{job}, $s->{testid}, @blessings);
        if (!$anypassq->fetchrow_hashref()) {
            print MRO "never-passed $j->{job} $s->{testid} $st\n";
            print DEBUG " never passed\n";
            $failv->{Summary}= 'never pass';
            $failv->{Blocker}= '';
            next;
        }

	my @rtups;
	push @rtups, [ 10, 0, "baseline untested", undef ];

	findaflight('that', $fi->{Flight}, $j->{job}, $s->{testid}, sub {
            my ($chkflight, $chkst) = @_;
	    my $rtup;
            # NB magic priority threshold, >=500 prevents heisen search
	    if (!defined $chkst) {
		$rtup= [ 50, '', "blocked in", $chkflight ];
	    } elsif ($chkst eq $st) {
		$rtup= [ 190, '', "like", $chkflight ];
	    } elsif ($chkst eq 'fail') {
		$rtup= [ 180, '', "failed in", $chkflight ];
	    } elsif ($chkst eq 'pass') {
                my $tblocker = $st eq 'fail' ? 'regression' : $st;
                my $tpriority = $j->{job} =~ m/^build/ ? 600 : 100;
		$rtup= [ $tpriority, $tblocker, "REGR. vs.", $chkflight ];
	    } else {
		$rtup= [ 170, '', "$chkst in", $chkflight ];
	    }
	    push @rtups, $rtup;
	    return $rtup->[2];
        });
	@rtups= sort { $b->[0] <=> $a->[0] } @rtups;
        print DEBUG Dumper($failv,\@rtups);
        my ($bpriority,$blocker) = @{ $rtups[0] };
        my $heisen;
        if ($blocker && $bpriority < 500) {
            my $heisengoodflight=
                !keys %{ $specver{this} } ? undef :
              findaflight('this', $fi->{Flight}, $j->{job}, $s->{testid}, sub {
                my ($heisenchkflight, $heisenchkst) = @_;
                return "not executed" unless defined $heisenchkst;
                return "not pass ($heisenchkst)" unless $heisenchkst eq "pass";
                return undef;
            });
            if ($heisengoodflight) {
                unshift @rtups, [ 20, '', "pass in", $heisengoodflight ];
                $failv->{Heisen}= 1;
                push @heisenflights, $heisengoodflight;
                $blocker='';
            }
        }
        if ($blocker) {
            my $item= "$failv->{Job}{job} $failv->{Step}{testid}";
            print DEBUG " allow $item?";
            foreach my $allowpat (@allows) {
                next unless $item =~ m/$allowpat/;
                $blocker='';
                print DEBUG " allowed";
                last;
            }
            print DEBUG "\n";
        }
	$failv->{Blocker}= $blocker;
        $failv->{Allow}= 1;
	$failv->{SummaryCore}= $rtups[0][2];
	$failv->{SummaryRefFlight}= $rtups[0][3];
	$failv->{Summary}= $failv->{SummaryCore};
        $failv->{Summary}.= ' '.displayflightnum($failv->{SummaryRefFlight})
            if defined $failv->{SummaryRefFlight};
	print DEBUG " so $failv->{Summary}\n";
        print DEBUG " blocker $failv->{Blocker}\n" if $failv->{Blocker};
        if ($failv->{Blocker} eq 'regression') {
            print MRO "regression $j->{job} $s->{testid}".
                " $failv->{SummaryRefFlight}\n" or die $!;
            next;
        }
    }

    foreach my $heisenflight (@heisenflights) {
        next if $heisenflight==$specflight;
        next if $heisenjustified{$heisenflight}++;
        print DEBUG "RECURSING HEISENFLIGHT $heisenflight...\n";
        my $heisen_fi= examineflight($heisenflight);
        push @failures, justifyfailures($heisen_fi, $fi->{Flight});
        print DEBUG "RECURSING HEISENFLIGHT $heisenflight done ",
              scalar(@failures), "\n";
    }

    if (!$heisen_why) {
	if (!@failures) {
	    print MRO "tolerable\nperfect\n" or die $!;
	    $fi->{Overall}.= "Perfect :-)\n";
	} elsif (grep { $_->{Blocker} eq 'regression' } @failures) {
	    $fi->{OutcomeSummary}= "regressions - $fi->{OutcomeSummary}";
	    $fi->{Overall}.= "Regressions :-(\n";
	} elsif (!grep { $_->{Blocker} } @failures) {
	    $fi->{OutcomeSummary}= "tolerable $fi->{OutcomeSummary}";
	    print MRO "tolerable\n" or die $!
		unless defined $heisen_why;
	    $fi->{Overall}.= "Failures :-/ but no regressions.\n";
	} else {
	    $fi->{Overall}.= "Failures and problems with tests :-(\n";
	}
    }

    return @failures;
}

sub htmloutjob ($$) {
    my ($fi,$job) = @_;
    return unless defined $htmldir;

    my $jobhtmldir = "$htmldir/$job";
    mkpath $jobhtmldir;

    my $htmlfile= "$jobhtmldir/$htmlleaf";
    open H, "> $htmlfile.new" or die "$htmlfile.new $!";

    my $title= "Info on flight $fi->{Flight} job $job";
    my $branch= $fi->{FlightInfo}{branch};

    our $htmlout_jobq ||= db_prepare(<<END);
        SELECT * FROM jobs WHERE flight = ? AND job = ?
END
    $htmlout_jobq->execute($fi->{Flight}, $job);
    my $ji = $htmlout_jobq->fetchrow_hashref();
    die unless $ji;

    print H <<END;
<html><head><title>$title</title><head>
<body>
<h1>$title</h1>
<ul>
<li><a href="../">Flight $fi->{Flight} scoreboard</a>
<li><a href="$c{ResultsHtmlPubBaseUrl}/history/$job/ALL">History for $job</a>
<li><a href="$c{ResultsHtmlPubBaseUrl}/history/$job/$branch">History for $job in tests of $branch</a>
<li><a href="./">Logfiles for $fi->{Flight} $job as webserver directory listing</a>
</ul>
<h2>Steps</h2>
<table rules=all>
<tr><th>stepno</th><th>testid</th><th>script</th><th>status</th>
<th>started</th><th>duration</th></tr>
END

    my %issteplog;
    my $stepsq= db_prepare(<<END);
        SELECT * FROM steps
                WHERE flight=? AND job=?
             ORDER BY stepno ASC
END
    $stepsq->execute($fi->{Flight}, $job);
    my $stepstripe= 0;
    while (my $step= $stepsq->fetchrow_hashref()) {
        printf H "<tr bgcolor='%s'>",
            ($step->{stepno} & 1 ? '#cccccc' : '#ffffff');

        my $stepcol= sub {
            printf H "<td%s>%s</td>", $_[1], encode_entities($step->{$_[0]});
        };
        $stepcol->('stepno', ' align=right');
        $stepcol->('testid', '');
        $stepcol->('step', '');

        my $st= $step->{status};
        my $logfilename= "$step->{stepno}.$step->{step}.log";
        printf H "<td bgcolor='%s'><a href='%s'>%s</a></td>",
	    (html_status2_colour_priority($st))[0],
            encode_entities(uri_escape($logfilename)),
            encode_entities($st);
        $issteplog{$logfilename}= 1;

        printf H "<td>%s</td>", show_abs_time $step->{started};

	if (defined $step->{finished} && defined $step->{started}) {
	    printf H "<td align=right>%d</td>\n",
                $step->{finished} - $step->{started};
	} else {
	    printf H "<td></td>\n";
	}
    }

    print H <<END;
</table>
<h2>Job</h2>
<table>
<tr><td>Recipe:</td><td>$ji->{recipe}</td></tr>
<tr><td>Status:</td><td>$ji->{status}</td></tr>
</table>
<p>
<h2>Logfiles etc.</h2>
For main test script logfiles, see entries in steps table.
<ul>
END
    opendir LOGS, "$htmldir/$job" or die "$htmldir/$job $!";
    my @dents= sort readdir LOGS;
    closedir LOGS or die $!;
    foreach my $dent (@dents) {
        next if $dent eq "$htmlleaf.new" or $dent eq $htmlleaf
            or $dent eq '..' or $dent eq '.' or $issteplog{$dent};
        stat("$htmldir/$job/$dent") or die "$dent $!";
        print H "<li><a href=\"".encode_entities(uri_escape($dent))."\">".
            encode_entities($dent).(-d _ ? "/" : "")."</a>\n";
        if ($dent eq 'build') {
            print H " (outputs from build)";
        }
    }
    print H <<END;
</ul>
<h2>Test control variables</h2>
<table rules=all><tr><th>Name</th><th>Value</th><th>Source</th></tr>
END
    my $varsq= db_prepare(<<END);
        SELECT * FROM runvars
                WHERE flight=? AND job=?
             ORDER BY synth, name
END
    $varsq->execute($fi->{Flight}, $job);
    while (my $varrow= $varsq->fetchrow_hashref()) {
        print H "<tr><th>".encode_entities($varrow->{name})."</th>";
        print H "<td>".encode_entities($varrow->{val})."</td>";
        print H "<td>".($varrow->{synth} ? 'execution' : 'definition')."</td>";
        print H "\n";
    }
    print H "</table></body></html>\n";

    H->error and die $!;
    close H or die $!;
    rename "$htmlfile.new", $htmlfile or die $!;
}

sub html_status2_colour_priority ($) {
    my ($st) = @_;
    return ($st eq 'pass' ? ('#008800',100) :
            $st eq 'fail' ? ('#ff8888',200) :
            ('#ffff00',300));
}

sub htmlout ($) {
    my ($fi) = @_;
    return unless defined $htmldir;

    my @cols= @{ $fi->{GridCols} };

    htmloutjob($fi, $_) foreach @cols;

    my $htmlout= "$htmldir/index.html";
    open H, "> $htmlout.new" or die "$htmlout.new $!";
    print H <<END;
<html><head><title>Report on flight $fi->{Flight}</title><head>
<body>
<table rules=all>
END
    print H "<tr><th>";
    print H encode_entities($fi->{FlightInfo}{branch}).' ';
    print H encode_entities($fi->{FlightInfo}{blessing});
    print H "</th>\n";

    foreach my $col (@cols) {
        my $th= $col;
        $th =~ s/\-/ $&/g;
        print H "<th>";
        print H "<a href=\"".encode_entities($col)."/$htmlleaf\">";
        print H encode_entities($th);
        print H "</a>";
        print H "</th>";
    }
    print H "\n";
    print H "<tr><th rowspan=2>";
    print H "Last pass / First worst fail";
    print H "</th>";

    my $cell_html = sub {
	my ($ei, $core_only) = @_;
	# => ($h, $priority, $ch);
	my $s= $ei->{Step};
	my $sum_core= $ei->{SummaryCore};
	$sum_core= $ei->{Summary} if !defined $sum_core;
	my $sum_flight= $ei->{SummaryRefFlight};
	my $bgc;
	my $priority;
	if (!defined $sum_core || !length $sum_core) {
	    $sum_core= $s->{status};
	    ($bgc,$priority)= html_status2_colour_priority($s->{status});
	} else {
	    $sum_core= "$s->{status} $sum_core" unless $core_only;
	    ($bgc,$priority) =
		$ei->{Blocker} eq 'regression'
		? ('#ff8888',400)
		: ('#ffff00',250);
	}
	my $ch = "bgcolor=\"$bgc\"";
	my $h = "<a href=\"".encode_entities($s->{job}).
	    "/$s->{stepno}.".encode_entities($s->{step}).".log\">";
	#print H "[$s->{stepno}] ";
	$h .= encode_entities($sum_core);
	$h .= "</a>";
	if (defined $sum_flight) {
	    $h .= " <a href=\"../$sum_flight/\">".
		displayflightnum($sum_flight)."</a>";
	}
	return ($h,$priority,$ch);
    };

    my @worstrow1;
    my @worstrow2;
    foreach my $col (@cols) {
	# @worst = ( $cell_html->(stuff), $failing_stepid_html ) =
	# ($step_cell_html, $priority, $colour_attr, $failing_stepid_html)
	my @worst=('',0,'bgcolor="#444444"','');
	foreach my $rowix (0..$#{ $fi->{GridRows} }) {
            my $ei= $fi->{GridGrid}{$col}[$rowix];
	    next unless $ei;
	    my @this = $cell_html->($ei);
	    next if $this[1] < $worst[1];
	    next if $this[1] == $worst[1] && $ei->{Step}{status} ne 'pass';
	    @worst=@this;
	    push @worst,
	        encode_entities("$ei->{Step}{stepno}. $ei->{Step}{testid}");
	}
	push @worstrow1, "<td ",$worst[2],">",$worst[3],"</td>";
	push @worstrow2, "<td ",$worst[2],">",$worst[0],"</td>";
    }
    print H "\n", @worstrow1, "\n<tr>\n", @worstrow2;
    print H "\n";
    # Create a gutter row after the headers.
    print H "<tr><td>&nbsp;</td></tr>\n";

    foreach my $rowix (0..$#{ $fi->{GridRows} }) {
        next unless $fi->{GridRows}[$rowix];
        my $rowdesc= encode_entities($fi->{GridRows}[$rowix]);
        print H "<tr><th>$rowdesc</th>";

        my $ndeferred= 0;
        my $colix= 0;
        my $deferred_cells= sub {
            my ($now) = @_;

            my $min= 3;

            my $label;
            $label= sub {
                my ($nuse, $align) = @_;
                return unless $nuse;
                die unless $nuse <= $ndeferred;

                print H "<td bgcolor=\"#444444\" colspan=$nuse align=$align>";
                if ($nuse >= $min) {
                    print H $rowdesc;
                }
                print H "</td>";
                $ndeferred -= $nuse;
            };

            if ($colix>$ndeferred && $ndeferred >= ($now ? $min*2 : $min)) {
                $label->($min, 'left');
            }
            while ($ndeferred > $min) {
                $label->(1, 'right');
            }
            $label->($ndeferred, 'right');
        };

        foreach my $col (@cols) {
            my $ei= $fi->{GridGrid}{$col}[$rowix];
            if ($ei) {
                $deferred_cells->(1);
                my $s= $ei->{Step};
		my ($h,$priority,$ch) = $cell_html->($ei, 1);
                print H "<td ",$ch,">",$h,"</td>";
            } else {
                $ndeferred++;
            }
            $colix++;
        }
        $deferred_cells->(0);
        print H "\n";
    }
    print H "</table>";

    my %vercols;
    foreach my $tt (qw(this that)) {
        my $ary= $specver{$tt};
        next unless $ary;
        $vercols{$_}=1 foreach keys %$ary;
    }
    my @vercols= sort keys %vercols;
    if (@vercols) {
        print H "<h2>Targeted versions</h2>\n";
        print H "<table rules=all>";
        print H "<tr><td></td>";
        print H "<th>".encode_entities($_)."</th>" foreach @vercols;
        foreach my $tt (qw(this that)) {
            my $ary= $specver{$tt};
            next unless $ary;
            print H "<tr>";
            print H "<th>".($tt eq 'that' ? 'baseline' : $tt)."</th>";
            foreach my $vc (@vercols) {
                my $v= $ary->{$vc};
                print H "<td>";
                print H encode_entities($v) if defined $v;
                print H "</td>";
            }
        }
        print H "</table>";
    }
    my $started_str = show_abs_time $fi->{FlightInfo}{started};

    our $htmlout_finishedq ||= db_prepare(<<END);
        SELECT
 (SELECT max(finished) FROM steps WHERE flight=?)                 max,
 (SELECT count(*) FROM steps WHERE finished IS NULL AND flight=?) unfinished
END
    $htmlout_finishedq->execute($fi->{Flight}, $fi->{Flight});
    my $frow = $htmlout_finishedq->fetchrow_hashref();
    my $finished_str =
	$frow->{unfinished} ? "($frow->{unfinished} unfinished steps)" :
	!$frow->{max} ? "(no steps)" :
	show_abs_time($frow->{max});

    print H <<END;
<h2>Flight information</h2>
<table>
<tr>
<td>"Branch":</td><td>$fi->{FlightInfo}{branch}</td></tr>
<td>Intended blessing:</td><td>$fi->{FlightInfo}{intended}</td></tr>
<td>Blessing:</td><td>$fi->{FlightInfo}{blessing}</td></tr>
<td>Started:</td><td>$started_str</td></tr>
<td>Finished:</td><td>$finished_str</td></tr>
<td>Test harness revision(s):</td><td>
END

    our $htmlout_touchedq ||= db_prepare(<<END);
        SELECT harness FROM flights_harness_touched WHERE flight=?
END
    $htmlout_touchedq->execute($fi->{Flight});
    while (my ($touched) = $htmlout_touchedq->fetchrow_array()) {
	print H $touched, "\n";
    }

    print H <<END;
</td></tr>
</table>
END
    print H "</body></html>";
    H->error and die $!;
    close H or die $!;
    rename "$htmlout.new", $htmlout or die $!;
}

db_begin_work($dbh_tests, [qw(flights)]);
findspecflight();
my $fi= examineflight($specflight);
my @fails= justifyfailures($fi);
printout($fi, @fails);
htmlout($fi);

if (defined $mro) {
    close MRO or die $!;
    rename "$mro.new",$mro or die $!;
}
