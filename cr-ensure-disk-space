#!/usr/bin/perl -w
#
# Ensure there's enough free space

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.



use strict qw(vars);
use Osstest;
use Osstest::Management qw(:logs);
use Fcntl qw(:flock);

our $dryrun= 0;

open DEBUG, ">/dev/null" or die $!;

while (@ARGV && $ARGV[0] =~ m/^\-/) {
    $_= shift @ARGV;
    last if $_ eq '--';
    if (m/^-n$/) {
        $dryrun= 1;
    } elsif (m/^-D$/) {
        open DEBUG, ">&2" or die $!;
    } else {
	die "$_ ?";
    }
}

die unless @ARGV==1;

our ($cfgbase) = @ARGV;

csreadconfig();

logs_select $cfgbase or exit 0;

open LOCK, "> $c{GlobalLockDir}/publish-lock" or die $!;
flock LOCK, LOCK_EX or die $!;

$|=1;

my $chkq= db_prepare("SELECT * FROM flights WHERE flight=?");

my $refq= db_prepare(<<END);
    SELECT flight, val
      FROM runvars
     WHERE name like '%job'
       AND val like '%.%'
       AND flight >= ?
END

our @flights;
our %latestref;

for (;;) {
    open P, "-|", onloghost "df --block-size=1M -P $logdir" or die $!;
    $_= <P>;
    m/^filesystem/i or die "$_ ?";
    $_= <P>;
    m,^\S+\s+\d+\s+\d+\s+(\d+)\s+, or die "$_ ?";
    $!=0; $?=0; close P or die "$! $?";
    my $space= $1;
    printf "space: %8d, wanted: %8d ", $space, logcfg('MinSpaceMby');
    last if $space >= logcfg('MinSpaceMby');

    if (!@flights) {
	%latestref = ();
	open P, "-|", onloghost "ls -1 $logdir" or die $!;

	my $minflight = undef;
	while (<P>) {
	    next unless m/^(\d+)\n$/;
	    $latestref{$1} = $1;
	    $minflight //= $1;
	    $minflight = $1 if $1 < $minflight;
	}
	$!=$?=0; close P or die "ls: $? $!";

	print DEBUG "MINFLIGHT $minflight\n";

	$refq->execute($minflight);
	while (my $rr= $refq->fetchrow_hashref) {
	    my $testflight = $rr->{flight};
	    next unless $rr->{val} =~ m/^(\d+)\./;
	    my $buildflight = $1;
	    next unless exists $latestref{$buildflight};
	    if ($testflight > $latestref{$buildflight}) {
		print DEBUG "REF $buildflight <- $testflight\n";
		$latestref{$buildflight} = $testflight;
	    }
	}

	@flights =
	    sort { $latestref{$b} <=> $latestref{$a} }
	    keys %latestref;
        printf "(%d flights) ", scalar @flights;
        die unless @flights;
    }
    my $flight = pop @flights;
    my $latestref = $latestref{$flight};
    printf "selected %s (latest ref %s) ", $flight, $latestref;

    $chkq->execute($latestref);
    my $row= $chkq->fetchrow_hashref();
    $chkq->finish();
    die "$flight $latestref" unless defined $row;
    my $age= time - $row->{started};

    printf "(age %dd) ", $age / 86400;

    die "age $age" if $age < logcfg('MinExpireAge');

    printf "...";

    die if $dryrun;

    my $spawn= sub {
        $!=0; my $r= system @_; die "@_ $r $!" if $r;
    };
    $spawn->(onloghost <<END);
             set -e
             cd $logdir
             test -e $flight || exit 0
             printf remote...
             rm -rf $flight
END

    printf "done.\n";
}

printf "ok.\n";
exit 0;
