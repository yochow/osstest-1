#!/usr/bin/perl -w
#
# Compute the best combination of things to test for another
# bisection step.  Create a flight with appropriate builds and
# tests.
#
# usage:
#   ./cs-bisection-setup [<options>] <branch> <job> <testid>
#      --blessings=real,real-bisect

use strict qw(vars);
use Osstest;
use Data::Dumper;
no warnings qw(recursion);

our @blessings= qw(real real-bisect);

my $graphfile= 'bisection';
my $popflight= 0;

our $worst_estatus= -1;
our $estatus= 255;
END { $?= $estatus; }

# exit status
#   0    have identified a revision to test
#   4    bisection complete and successful
#   8    bisection finished and inconclusive
#  12    bisection finished, but inconsistent test results cast doubt
#  16    fatally inconsistent test results
# 255    doom and disaster

open DEBUG, ">/dev/null" or die $!;
open SUMMARY, ">/dev/null" or die $!;

while (@ARGV && $ARGV[0] =~ m/^\-/) {
    $_= shift @ARGV;
    last if $_ eq '--';
    if (s/^--blessings=//) {
	@blessings= split /\,/;
	next;
    } elsif (m/^--graph-out=(.+)$/) {
        $graphfile= $1;
    } elsif (m/^--summary-out=(.+)$/) {
        open SUMMARY, "> $1" or die $!;
    } elsif (m/^--no-graph-out$/) {
        $graphfile= '';
    } elsif (m/^--flight=(\d+)$/) {
        $popflight= $1;
    } elsif (m/^-D$/) {
        open DEBUG, ">&2" or die $!;
        DEBUG->autoflush(1);
    } else {
	die "$_ ?";
    }
}

@ARGV==3 or die;
our ($branch,$job,$testid) = @ARGV;

our ($latest_flight, $hosts, $earliest_flight);
our (@trees);

our $blessingscond= '('.join(" OR  ", map { "blessing='$_'" } @blessings).')';

sub psummary ($) {
    my ($s) = @_;
    print STDERR $s or die $!;
    print SUMMARY $s or die $!;
}

sub summary_report ($$$) {
    my ($heading,$body,$new_estatus) = @_;
    psummary("\n");
    if (length $heading) {
        chomp $heading;
        psummary("*** $heading ***\n");
    }
    if (length $body) {
        chomp $body;
        $body =~ s/^/  /gm;
        psummary("$body\n");
    }
    if ($new_estatus > $worst_estatus) {
        $worst_estatus= $new_estatus;
    }
}

sub relevant_hosts ($) {
    my ($flight) = @_;
    my $sth= $dbh_tests->prepare(<<END);
        SELECT name,val FROM runvars
	   WHERE job = ?
	     AND flight = ?
	     AND name LIKE '%host'
END
    $sth->execute($job,$latest_flight);
    return join ',', map { join '=', @$_ } @{ $sth->fetchall_arrayref() }
}

sub flight_has_relevant_hosts ($) {
    my ($flight) = @_;
    my $hosts= relevant_hosts($flight);
}

sub flight_rtuple ($) {
    my ($flight) = @_;

    $dbh_tests->do(<<END, {}, $job, $flight);
    
        SELECT t.name AS use,
	       b.name AS name,
	       b.val  AS val

          INTO TEMP TABLE tmp_build_info
	       
	  FROM runvars AS t
    CROSS JOIN runvars AS b
    
           WHERE t.job = ?
	     AND t.flight = ?
	     AND t.name LIKE '%buildjob'
	     AND ((t.val NOT LIKE '%.%' AND b.flight=t.flight AND t.val=b.job)
	       OR (t.val LIKE '%.%' AND t.val = b.flight || '.' || b.job))

END
    my $sth= $dbh_tests->prepare(<<END);

        SELECT url.val AS uval,
	       rev.val AS rval

	    FROM tmp_build_info AS rev
      CROSS JOIN tmp_build_info AS url

           WHERE rev.name LIKE E'built\\_revision\\_%'
  	     AND url.name LIKE E'tree\\_%'
	     AND rev.use = url.use
	     AND rev.name = 'built_revision_' || substr(url.name,6)

	   ORDER by url.val;
	  
END
    $sth->execute();
    my $row;
    my $mixed=0;
    my (@turls, @trevisions);
    while ($row= $sth->fetchrow_hashref()) {
	if (@turls && $row->{uval} eq $turls[-1]) {
	    if ($row->{rval} ne $trevisions[-1]) {
		print STDERR "!! flight $flight mixed revisions for $turls[-1]: $trevisions[-1] and $row->{rval}\n";
		$mixed=1;
	    }
	} else {
	    push @turls, $row->{uval};
	    push @trevisions, $row->{rval};
	}
    }
    $dbh_tests->do(<<END);
        DROP TABLE tmp_build_info
END
    return () if $mixed;
    if (!@turls) {
	print STDERR "!! flight $flight no revisions or trees\n";
	return ();
    }
    if (!@trees) {
	@trees= @turls;
	psummary("Tree: $_\n") foreach @trees;
    }
    if ("@trees" ne "@turls") {
	print STDERR "!! flight $flight different trees: @turls\n";
	return ();
    }
    map { s/\+//g; s/^\d+://; } @trevisions;
    return @trevisions;
}

sub findbasics () {
    my $sth= $dbh_tests->prepare(<<END);
	SELECT * FROM flights NATURAL JOIN steps
	   WHERE job = ?
	     AND testid = ?
	     AND blessing = ?
	     AND (status = 'fail' OR status = 'pass')
             AND branch = ?
	   ORDER BY started DESC
	   LIMIT 1
END
    $sth->execute($job,$testid,$blessings[0],$branch);
    my $row= $sth->fetchrow_hashref();
    die "no failure found" unless $row;
    die "last flight not a failure $row->{flight} $row->{status}"
        unless $row->{'status'} eq 'fail';
    $latest_flight= $row->{flight};
    print STDERR "Found failure, as expected, in flight $latest_flight\n";

    $hosts= relevant_hosts($latest_flight);
    print STDERR "Host specification list: $hosts\n";

    print STDERR "Searching for last pass:";
    $sth= $dbh_tests->prepare(<<END);
        SELECT * FROM flights NATURAL JOIN steps
	   WHERE job = ?
	     AND testid = ?
	     AND blessing = ?
	     AND status = 'pass'
             AND branch = ?
	   ORDER BY started DESC
END
    $sth->execute($job,$testid,$blessings[0],$branch);
    while ($row= $sth->fetchrow_hashref()) {
	print STDERR " $row->{flight}";
	next unless flight_has_relevant_hosts($row->{flight});
	$earliest_flight= $row->{flight};
	last;
    }
    if (!$earliest_flight) {
	die "\nNo applicable pass, sorry!\n";
    }
    print STDERR ".\n";
}

our (%nodes, @latest_rtuple, @earliest_rtuple);

sub digraph_whole () {
    @latest_rtuple= flight_rtuple($latest_flight);
    print STDERR "Latest @latest_rtuple\n";
    @earliest_rtuple= flight_rtuple($earliest_flight);
    if (!@earliest_rtuple) {
	die "Latest pass $earliest_flight rtuple indeterminate/wrong\n";
    }
    print STDERR "Earliest @earliest_rtuple\n";

    my $cmd= "./adhoc-revtuple-generator";
    foreach (my $i=0; $i<@trees; $i++) {
        $cmd.= ' '.$trees[$i].'#'.$earliest_rtuple[$i].'-'.$latest_rtuple[$i];
    }
    print STDERR "Generating revisions with $cmd\n";
    open REVLIST, "$cmd |" or die $!;
    while (<REVLIST>) {
        chomp;
        last if $_ eq '.';
        my $rtuple= $_;
        $!=0; $_=<REVLIST>;
        m/^(\d+) (\d+)$/ or die "$! $_ ?";
        $nodes{$rtuple}{Date}= $1;
        my $n= $nodes{$rtuple};
        my $nparents= $2;
        while ($nparents--) {
            $!=0; $_=<REVLIST>;
            chomp or die $!;
            push @{ $nodes{$_}{Children} }, $n;
            push @{ $n->{Parents} }, $nodes{$_};
        }
    }
    $!=0; $?=0; close REVLIST or die "$? $!";

    foreach my $rtuple (keys %nodes) {
        $nodes{$rtuple}{Rtuple}= $rtuple;
    }
    print STDERR "Loaded ".scalar(keys %nodes)." nodes in revision graph\n";

#print DEBUG Dumper(\%nodes),"\n";
}

sub walk ($$$;$);
sub walk ($$$;$) {
    my ($n, $parch, $code, $depth) = @_;
    return unless defined $n;
    $depth=0 unless defined $depth;
    return if $code->($n, $depth);
    foreach my $neigh (@{ $n->{$parch} }) {
        walk($neigh, $parch, $code, $depth+1);
    }
}

sub digraph_relevant () {
    my $paint_relevant;
    $paint_relevant= sub {
        my ($start, $parch, $paint) = @_;
        walk($start, $parch, sub {
            my ($n, $depth) = @_;
            #print DEBUG "PAINT_RELEVANT $parch $paint $depth $n->{Rtuple}\n";
            return $n->{$paint}++;
        });
    };
    $paint_relevant->($nodes{"@latest_rtuple"}, Parents, RelvDown);
    $paint_relevant->($nodes{"@earliest_rtuple"}, Children, RelvUp);

    foreach my $rtuple ("@latest_rtuple", "@earliest_rtuple") {
        foreach my $relflag (qw(RelvDown RelvUp)) {
            die "not $relflag at $rtuple" unless $nodes{$rtuple}{$relflag};
        }
    }
}

our @failures;

sub relevant ($) {
    my ($n) = @_;
    defined($n) and $n->{RelvDown} and $n->{RelvUp};
}

sub scantests () {
    my $earliest_date= $nodes{"@earliest_rtuple"}{Date};

    print STDERR "Searching for test results:\n";

    my $sth= $dbh_tests->prepare("
       SELECT * FROM flights NATURAL JOIN steps
          WHERE job = ?
            AND testid = ?
            AND $blessingscond
            AND started >= $earliest_date
            AND branch = ?
    ");
    $sth->execute($job, $testid, $branch);
    while (my $row= $sth->fetchrow_hashref()) {
        my @rtuple= flight_rtuple($row->{flight});
	next unless @rtuple;
        print STDERR " $row->{flight} $row->{status} ";
        my $n= $nodes{"@rtuple"};
        if (!relevant($n)) {
            print STDERR "irrelevant\n";
            next;
        }
        print STDERR "@rtuple\n";

        push @{ $n->{Flights} }, {
            Flight => $row->{flight},
            Result => $row->{status},
            Blessing => $row->{blessing}
        };

        if ($row->{status} eq 'fail') {
            push @failures, $n;
            walk($n, Children, sub {
                my ($desc, $depth) = @_;
                return 0 unless $depth;
                return $desc->{UninterestingFailure}++;
            });
        }
    }
}

our @conflicted;

sub consolidateresults () {
    foreach my $n (values %nodes) {
        my $fs= $n->{Flights};
        my %r;
        $r{ $_->{Result} }=1 foreach @$fs;
        next unless %r;
        $n->{Result}= (keys %r)[0] if scalar(keys %r) == 1;
        if (scalar(keys %r) > 1) {
            $n->{Conflicted}= 1;
            push @conflicted, $n;
        }
    }
}

our @interesting_lengths;

sub search_compute_length_at ($);
sub search_compute_length_at ($) {
    my ($n) = @_;
    print DEBUG "CLA $n->{Rtuple} ";
    if (!relevant($n)) {
        print DEBUG "X (irrelevant)\n";
        return 'X';
    }
    if (defined $n->{Result}) {
        print DEBUG "0 ($n->{Result})\n";
        die "$n->{Rtuple} $n->{Result} " if $n->{Result} eq 'fail';
        if ($n->{Result} ne 'pass') {
            search_compute_length_below($n);
        }
        $n->{LengthAt}= 0;
        return 0;
    }
    my $res= 1;
    print DEBUG ".. x".scalar(@{ $n->{Parents} })."\n";
    foreach my $parent (@{ $n->{Parents} }) {
        my $t= search_compute_length_at($parent);
        next if $t eq 'X';
        $res += $t;
    }
    $n->{LengthAt}= $res;
    return $res;
}

sub search_compute_length_below ($) {
    my ($base) = @_;
    return if $base->{UninterestingFailure};
    print DEBUG "CLB $base->{Rtuple}\n";
    foreach my $n (@{ $base->{Parents} }) {
        next if exists $n->{InterestingLength};
        my $t= search_compute_length_at($n);
        next if $t eq 'X';
        $n->{InterestingLength}= $t;
        print STDERR " $t revisions at $n->{Rtuple}\n";
        push @interesting_lengths, $n;
    }
}

sub choose_revision_below ($$);
sub choose_revision_below ($$) {
    my ($n, $count) = @_;

    print DEBUG "CRB $count $n->{Rtuple}\n";

    return $n if $count <= 0;

    my $parents= $n->{Parents};
    die "reached end $n->{Rtuple} !" unless @$parents;

    my ($descend, @bypass) = sort {
        $b->{LengthAt} <=> $a->{LengthAt}
    } grep {
        defined $_->{LengthAt}
    } @$parents;
    # $bypass is the parent with the biggest LengthAt, so
    # the one we're going to investigate.

    $count--;
    $count -= $_->{LengthAt} foreach @bypass;

    return choose_revision_below($descend, $count);
}

our $choose;

sub do_choose_this ($) {
    my ($n) = @_;
    $choose= $n;
    print STDERR "Should test $choose->{Rtuple}.\n";
    $choose->{Target}= 1;
}

sub conflicted_warning ($$) {
    my ($n, $what) = @_;
    if ($n->{Conflicted}) {
        summary_report(<<END, <<END, 16);
Not reproducible - $what
END
Could not reproduce problem, or could not reproduce last pass.
Inconsistent test results were at this revision:
$n->{Rtuple}
END
        $n->{Target}= 1;
        return 1;
    }
}

sub need_reproduce ($$) {
    my ($n, $what) = @_;

    return 1 if conflicted_warning($n, $what);
    
    my $fl= $n->{Flights} ;
    if (@$fl < 2) {
        print STDERR "Need to double-check by reproducing $what.\n";
        do_choose_this($n);
        return 1;
    }
    return 0;
}

sub search () {
    print STDERR "Searching for interesting versions\n";

    return if need_reproduce($nodes{"@latest_rtuple"}, "failure");
    return if need_reproduce($nodes{"@earliest_rtuple"}, "last pass");

    foreach my $startfail (@failures) {
        search_compute_length_below($startfail);
    }
    my $best;
    foreach my $n (@interesting_lengths) {
        next if defined $best
            and $best->{InterestingLength} >= $n->{InterestingLength};
        $best= $n;
    }
    if (!$best->{InterestingLength}) {
        print STDERR "No revisions left to test, checking graph state.\n";

        my $found_exact_failure= 0;

        foreach my $fail (@failures) {
            next if conflicted_warning($fail, "first failure");
            my @passchildren;
            my $nope= 0;
            foreach my $pass (@{ $fail->{Children} }) {
                $nope=1 if conflicted_warning($pass, "last pass");
                next unless defined $pass->{Result};
                next unless $pass->{Result} eq 'pass';
                ($nope=1),next if conflicted_warning($pass, "last pass");
                push @passchildren, $pass;
            }
            next if $nope;
            next unless @passchildren;
            
            return if need_reproduce($fail, "first failure");
            foreach my $pass (@passchildren) {
                return if need_reproduce($_, "last pass");
            }

            $found_exact_failure++;
            $fail->{Target}= 1;
            
            summary_report(<<END,'', 4);
Found and reproduced problem changeset
END
            my @failrev= split / /, $fail->{Rtuple};

            for (my $i=0; $i<@trees; $i++) {
                foreach my $pass (@passchildren) {
                    my @passrev= split / /, $pass->{Rtuple};
                    next if $passrev[$i] eq $failrev[$i];

                    summary_report("",<<END, -1);
Bug is in tree:  $trees[$i]
Bug introduced:  $failrev[$i]
Bug not present: $passrev[$i]
END
                }
            }
        }
        if (!$found_exact_failure) {
            summary_report(<<END,<<END, 8);
Exact problem changeset not identified
END
See revision graph output for details.
END
        } elsif (@conflicted) {
            summary_report(<<END,<<END, 12);
HOWEVER - WARNING - INCONSISTENT TEST RESULTS
END
Some revisions produced unstable test results,
so interpret the results with caution.
See revision graph output for details.
END
        }
    } else {
        my $godown= ($best->{InterestingLength}) >> 1;
        print STDERR "Looking $godown below $best->{Rtuple}.\n";
        my $ch= choose_revision_below($best, $godown);
        choose_this($ch);
    }
}

sub gnodename ($) {
    my ($n) = @_;

    my $lab= $n->{Rtuple};
    $lab =~ s/(\S{12})\S+/$1/g;
    $lab =~ s/ /,/g;

    my $fs= $n->{Flights};
    if ($fs) {
        my $resultsdesc= join ' ', map {
            $_->{Flight}.':'.$_->{Result}
        } sort {
            $a->{Flight} <=> $b->{Flight}
        } @$fs;
        
        $lab.= "\\n".$resultsdesc;
    }
    return "\"$lab\"";
}

sub odot ($) { print DOT $_[0] or die $!; }

sub writegraph () {
    return unless length $graphfile;

    open DOT, "> $graphfile.dot" or die $!;
    
    odot(<<END);
digraph "$job $testid" {
  rankdir=BT;
  ranksep=0;
  nodesep=0.3;
  edge [arrowsize=0.2];
  node [shape=box, fontname=Courier, fontsize=9, style=filled];
END

    foreach my $n (values %nodes) {
        next unless relevant($n);

        odot("  ".gnodename($n)." ");
        my @s;

        if (defined $n->{Result}) {
            if ($n->{Result} eq 'fail') {
                push @s, 'fillcolor="red"';
                push @s, 'fontcolor="white"';
            } elsif ($n->{Result} eq 'pass') {
                push @s, 'fillcolor="green"';
                push @s, 'fontcolor="black"';
            } else {
                push @s, 'fillcolor="orange"';
                push @s, ' fontcolor="white"';
            }
        } elsif (defined $n->{Conflicted}) {
            push @s, ' fillcolor="yellow"';
            push @s, ' fontcolor="black"';
        } else {
        }

        if ($n->{Target}) {
            push @s, ' peripheries=2';
        }

        odot('[');
        odot(join ', ', @s);
        odot("];\n");
        

        foreach my $parent (@{ $n->{Parents} }) {
            odot("  ".gnodename($parent)." -> ".gnodename($n).";\n");
        }
    }
    odot("}\n");

    close DOT or die $!;

    $!=0; system "dot -Tps -o$graphfile.ps $graphfile.dot";
    die "$? $!" if $? or $!;

    print STDERR "Revision graph left in $graphfile.{dot,ps}.\n";
}

our %jobs_created;

sub preparejob ($$$);
sub preparejob ($$$) {
    my ($popjob, $copyflight, $cacheok) = @_;

    if (exists $jobs_created{$popjob}) {
	print STDERR "Already created $jobs_created{$popjob}\n";
	return $jobs_created{$popjob};
    }

    print STDERR "Need $popflight.$popjob (like $copyflight)\n";

    # Create a temporary table containing the runvars we want

    $dbh_tests->do(<<END, {}, $copyflight, $popjob);
        SELECT name, val
            INTO TEMP  bisection_runvars
                 FROM  runvars
                WHERE  flight=? AND job=? AND synth='f'
                  AND  name NOT LIKE E'revision\\_%'
END
    my (@trevisions) = split / /, $choose->{Rtuple};

    my $treeq= $dbh_tests->prepare(<<END);
        SELECT name FROM runvars
          WHERE  flight=? AND job=?
            AND  name LIKE E'tree\\_%'
            AND  val = ?
END
    foreach (my $i=0; $i<@trees; $i++) {
        $treeq->execute($copyflight, $popjob, $trees[$i]);
        my ($treevar) = $treeq->fetchrow_array();
        next unless defined $treevar;
        $treevar =~ m/^tree_/ or
            die "$copyflight $popjob $trees[$i] $treevar ";
        my $revname= "revision_$'";
        my $revval= $trevisions[$i];

        print STDERR " $revname=$revval\n";
        $dbh_tests->do(<<END, {}, $revname, $revval);
            INSERT INTO bisection_runvars VALUES (?, ?)
END
    }

    # Check for subjobs:

    my $jobq= $dbh_tests->prepare(<<END);
        SELECT name, val FROM runvars
            WHERE  flight=? AND job=?
              AND  name LIKE '%job';
END
    $jobq->execute($copyflight, $popjob);
    my $subjobs= $jobq->fetchall_arrayref( {} );

    # See if there's a build we can reuse

    my $recipeq= $dbh_tests->prepare(<<END);
        SELECT recipe FROM jobs WHERE flight=? AND job=?
END
    $recipeq->execute($copyflight,$popjob);
    my ($recipe) = $recipeq->fetchrow_array();

    my $usejob;

    if ($recipe =~ m/^build/ and !@$subjobs) {
        my $reuseq= $dbh_tests->prepare(<<END);
            SELECT  *
            FROM    flights f NATURAL JOIN jobs j
            WHERE   j.status='pass'
            AND     $blessingscond
            AND     0 = ( SELECT count(*)
                          FROM
                              ( SELECT name,val
                                FROM   runvars
                                WHERE  flight=f.flight AND job=? AND synth='f'
                              ) o
                          FULL OUTER JOIN
                              bisection_runvars want
                          USING (name)
                          WHERE (o.val = want.val) IS NOT TRUE
                        )
            ORDER BY started desc
            LIMIT 1
END
        $reuseq->execute($popjob);
        my $reusejob= $reuseq->fetchrow_hashref();
        if ($reusejob) {
            $usejob= "$reusejob->{flight}.$reusejob->{job}";
            print STDERR "Can reuse $recipe $usejob.\n";
        }
    }

    if (!defined $usejob) {
        print STDERR "Creating $popflight.$popjob (copying".
            " from $copyflight)\n";

        $dbh_tests->do(<<END, {}, $popflight,$popjob,$recipe);
            INSERT INTO jobs VALUES (?, ?, ?, 'queued')
END
        $dbh_tests->do(<<END, {}, $popflight,$popjob);
            INSERT INTO runvars (
                    SELECT ? as flight, ? as job, name, val, 'f'
                      FROM bisection_runvars
                                 )
END

        $usejob= "$popflight.$popjob";
        $jobs_created{$popjob}= $usejob;
    }

    $dbh_tests->do("DROP TABLE bisection_runvars");

    my $jobsetq= $dbh_tests->prepare(<<END);
        UPDATE runvars SET val=?
            WHERE  flight=? AND job=? AND name=?
END
    foreach my $subjob (@$subjobs) {
        my $target;
        my $jobspec= $subjob->{val};
        if ($jobspec =~ m/^(\d+)\.(\s+)$/) {
            $target= preparejob($1, $2, 1);
        } else {
            $target= preparejob($jobspec, $copyflight, 1);
        }
        $jobsetq->execute($target, $popflight, $popjob, $subjob->{name});
    }

    return $usejob;
}

sub populateflight () {
    return unless $popflight;

    if (!defined $choose) {
        print STDERR "No revision to test.\n";
        return;
    }

    db_retry($dbh_tests, sub {
        print STDERR "Populating $popflight...\n";
        preparejob($job, $latest_flight, 0);
    });

    print STDERR "Flight $popflight ready to go.\n";
}

sub compute_exitstatus () {
    die if $worst_estatus<0;
    die if $worst_estatus==0 and !defined($choose);
    $estatus= $worst_estatus;
}

csreadconfig();
findbasics();
digraph_whole();
digraph_relevant();
scantests();
consolidateresults();
search();
writegraph();
populateflight();
compute_exitstatus();
