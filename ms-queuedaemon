#!/usr/bin/tclsh8.4
# -*- Tcl -*- 
# usage: ./ms-queuedaemon  ... | logger

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


source ./tcl/daemonlib.tcl

set walkers {plan projection}

proc walker-globals {w} {
    # introduces queue_running, thinking[_after] for the specific walker
    foreach v {queue_running thinking thinking_after} {
	uplevel 1 [list upvar #0 $w/$v $v]
    }
}

proc foreach-walker {walkervar body} {
    global walkers
    upvar 1 $walkervar w
    foreach w $walkers {
	uplevel 1 walker-globals $w
	uplevel 1 $body
    }
}

proc catching-internally {what try {ifok {}}} {
    if {[catch {
	uplevel 1 $try
    } emsg]} {
        log "INTERNAL ERROR $what: $emsg"
    } else {
	uplevel 1 $ifok
    }
}

proc chan-destroy-stuff {chan} {
    dequeue-chan $chan destroy
    upvar #0 chan-info/$chan info
    catch { unset info }
}

proc dequeue-chan {chan why} {
    log-event "dequeue-chan $chan $why"

    global queue
    lremove queue $chan

    foreach-walker w {
	if {[info exists queue_running]} { lremove queue_running $chan }
    }

    # Reentrancy: this next loop can only trigger once, because
    # the queuerun-step-done won't ever start chan thinking again
    foreach-walker w {
	if {[info exists thinking] &&
	    ![string compare $thinking $chan]} {
	    queuerun-step-done $w $why
	}
    }
}

#---------- debug tracing for queues ----------

proc log-event {m} {
    global log_state_after
    log-state $m
    if {![info exists log_state_after]} {
        set log_state_after [after idle {
            unset log_state_after
            log-state tcl-idle
        }]
    }
}

proc log-state {m} {
    global need_queue_run queue

    set lhs [format "N=%d Q=%d (%-15.15s) " \
                 $need_queue_run [llength $queue] $queue]

    foreach-walker w {
	append lhs "| "
	if {[info exists queue_running]} {
	    append lhs [format "R=%-3d " [llength $queue_running]]
	    if {[info exists thinking]} {
		append lhs [format "T=%-7s " $thinking]
	    } else {
		append lhs [format "          "]
	    }
	    append lhs [format "(%-15.15s) " $queue_running]
	} else {
	    append lhs "                                  "
	}
    }

    log "$lhs | $m"
}

#---------- machinery for making sure we run the queue ----------
#
# variables:
#  $w/queue            chans that are waiting for resources
#  $w/queue_running    unset if not running, list of chans if running
#  need_queue_run      0: not needed; 1: needed if more resources; 2: force
# the $w/ variables are generally upvar'd with walker-globals

proc runneeded-ensure-will {need} {
    global runneeded_holdoff_after c need_queue_run
    log-event "runneeded-ensure-will $need (was $need_queue_run)"

    if {$need > $need_queue_run} { set need_queue_run $need }

    if {![info exists runneeded_holdoff_after]} {
	set runneeded_holdoff_after \
	    [after [expr {$c(QueueDaemonHoldoff) * 1000}] \
		 runneeded-perhaps-start]
    }
}

proc runneeded-perhaps-start {} {
    log-event runneeded-perhaps-start
    walker-globals plan
    global queue need_queue_run inhibit
    global runneeded_holdoff_after
    unset runneeded_holdoff_after

    if {$inhibit} return
    if {[info exists queue_running]} return
    if {!$need_queue_run} return

    set needed $need_queue_run
    set need_queue_run 0

    if {![llength $queue]} {
        plan-reset plan
        report-plan plan plan
        return
    }

    jobdb::transaction resources {
        set nrows [pg_execute dbh {
            UPDATE resources
               SET owntaskid= (SELECT taskid FROM tasks
                               WHERE type='magic' AND refkey='allocatable')
         WHERE NOT (SELECT live FROM tasks WHERE taskid=owntaskid)
        }]
    }
    log "runneeded-perhaps-start allocable+=$nrows"

    if {!($nrows || $needed>=2)} return

    jobdb::transaction resources {
        set cleaned [pg_execute dbh {
            DELETE FROM tasks
             WHERE type='ownd'
               AND live='f'
               AND taskid + 10 <
                   (SELECT taskid FROM tasks
                     WHERE live='t' AND type='ownd'
                  ORDER BY taskid ASC
                     LIMIT 1)
        }]
    }
    log "runneeded-perhaps-start starting cleaned=$cleaned"

    runneeded-2-requeue
    restarter-starting-plan-hook
    queuerun-start plan
}

proc queuerun-finished/plan {} {
    runneeded-ensure-will 0
    report-plan plan plan
    report-plan plan projection
}

proc queuerun-finished/projection {} {
    runneeded-ensure-will 0
    report-plan projection projection
}

proc runneeded-ensure-polling {} {
    log-event runneeded-ensure-polling
    global polling_after queue c

    if {[info exists polling_after]} return
    if {![llength $queue]} return

    set polling_after [after [expr {$c(QueueResourcePollInterval)*1000}] \
                           runneeded-poll-now]
}

proc runneeded-poll-now {} {
    log-event runneeded-poll-now
    global polling_after
    unset polling_after
    runneeded-ensure-will 1
    runneeded-ensure-polling
}

proc runneeded-2-poll {} {
    log-event runneeded-2-poll
    global polling2_after
    unset polling2_after
    runneeded-ensure-will 2
    runneeded-2-requeue
}
proc runneeded-2-requeue {} {
    # (re)schedules forced queue run to QueuePlanUpdateInterval from now
    log-event runneeded-2-queue
    global c polling2_after
    catch { after cancel $polling2_after }
    set polling2_after [after [expr {$c(QueuePlanUpdateInterval)*1000}] \
                            runneeded-2-poll]
}

#---------- machinery for running the queue ----------
#
# variables:
#  queue                chans waiting, read when we start
#  $w/queue_running     chans not yet asked
#  $w/thinking          chan currently asking
#  $w/thinking_after    timeout
# all the $w/ are generally upvar'd by walker-globals

proc walkers-perhaps-queue-steps {} {
    foreach-walker w {
	after idle queuerun-perhaps-step $w
    }
}

proc plan-reset {w} {
    exec ./ms-planner -w$w reset < /dev/null
}

proc queuerun-start {w} {
    global queue
    walker-globals $w
    log-event "$w queuerun-start"
    plan-reset $w
    set queue_running $queue
    walkers-perhaps-queue-steps
}

proc queuerun-perhaps-step {w} {
    log-event "$w queuerun-perhaps-step"
    walker-globals $w
    global c

    if {[info exists thinking]} return
    if {![info exists queue_running]} return

    if {![llength $queue_running]} {
        unset queue_running
	queuerun-finished/$w
        return
    }

    set next [lindex $queue_running 0]
    if {![string compare RESTART $next]} {
	lshift queue_running
	restarter-restart-now
	return
    }

    set already [we-are-thinking $next]
    if {[llength $already]} {
	# $already will wake us via walkers-perhaps-queue-steps
	log-event "$w queuerun-perhaps-step already $already"
	return
    }

    set thinking $next
    lshift queue_running
    log-event "$w queuerun-perhaps-step selected"

    set thinking_after [after [expr {$c(QueueThoughtsTimeout) * 1000}] \
                            queue-thoughts-timedout $w]

    notify-to-think $w $thinking
}

proc report-plan {w wo} {
    global c
    catching-internally "showing $w html" {
	set outputfile "$c(WebspaceFile)/resource-$wo.html"
	exec ./ms-planner -w$w show-html > $outputfile
    } {
	set out data-$wo.final.pl
	file copy -force data-$w.pl $out.new
	file rename -force $out.new $out
        log "$w report-plan OK"
    }
}

proc we-are-thinking {chan} {
    set ws {}
    foreach-walker w {
	if {[info exists thinking] && ![string compare $thinking $chan]} {
	    lappend ws $w
	}
    }
    if {[llength $ws] > 1} {
	error "arrgh chan $chan thinking $ws !"
    }
    return [lindex $ws 0]
}

proc check-we-are-thinking {chan} {
    set w [we-are-thinking $chan]
    if {![string length $w]} {
        puts-chan $chan "ERROR you are not thinking"
        return -code return
    }
    return $w
}

proc queuerun-step-done {w why} {
    log-event "$w queuerun-step-done $why"
    walker-globals $w
    puts-chan-desc $thinking "$w queuerun-step-done $thinking $why"
    if {[info exists thinking_after]} {
        after cancel $thinking_after
        unset thinking_after
    }
    unset thinking
    walkers-perhaps-queue-steps
}

proc queue-thoughts-timedout {w} {
    log-event "$w queue-thoughts-timedout"
    walker-globals $w
    set chan $thinking
    unset thinking_after
    queuerun-step-done $w timeout
    for-chan $chan {
        puts-chan $chan "!ERROR timed out (too pensive)"
    }
}

proc cmd/thought-wait {chan desc} {
    set w [check-we-are-thinking $chan]
    queuerun-step-done $w thought-wait
    puts-chan $chan "OK thought"
}

proc cmd/thought-done {chan desc} {
    set w [check-we-are-thinking $chan]
    queuerun-step-done $w thought-done
    dequeue-chan $chan thought-wait
    puts-chan $chan "OK thought"
}

proc return-plan-to-client {chan wf} {
    set tplan [exec -keepnewline ./ms-planner -w$wf get-plan < /dev/null]
    puts-chan-data $chan "OK get-plan" $tplan
    return $tplan
}

proc cmd/get-plan {chan desc} {
    global plan
    set w [check-we-are-thinking $chan]
    set plan [return-plan-to-client $chan $w]
}

proc cmd/get-last-plan {chan desc w} {
    global walkers
    if {[lsearch -exact $walkers $w] < 0} { error "unknown last-plan ($w)" }
    if {![file exists data-$w.final.pl]} { error "no last-plan $w" }
    return-plan-to-client $chan $w.final
}

proc chan-plan-info {chan} {
    set desc [get-chan-desc $chan]
    set l {}
    lappend l [chan-get-info $chan {"$info(preinfo)"} ""]
    lappend l [chan-get-info $chan {"job $info(job)"} $desc]
    return [join $l " "]
}

proc cmd/book-resources {chan desc bytes} {
    read-chan-data $chan $bytes do-book-resources
}
proc do-book-resources {chan desc data} {
    global plan errorInfo
    set w [check-we-are-thinking $chan]
    set info [chan-plan-info $chan]
    if {[catch {
	exec ./ms-planner -w$w book-resources $info << $data
    } emsg]} {
	set f [exec ./ms-planner-debug -w$w $info $data $plan]
	error "$f $emsg" $errorInfo
    }
    puts-chan $chan "OK book-resources"
}

proc cmd/unwait {chan desc} {
    set w [we-are-thinking $chan]
    if {[string length $w]} {
        queuerun-step-done $w unwait
        set res "$w cancel"
    } else {
        set res noop
    }
    dequeue-chan $chan "unwait $res"
    puts-chan $chan "OK unwait $res"
}

#---------- special magic for restarting the plan ----------

proc for-free-resources {varname body} {
    jobdb::transaction resources {
	pg_execute -array free_resources_row dbh {
		SELECT (restype || '/' || resname || '/' || shareix) AS r
		  FROM resources
	     WHERE NOT (SELECT live FROM tasks WHERE taskid=owntaskid)
	      ORDER BY restype, resname
	} {
	    uplevel 1 [list set $varname $free_resources_row(r)]
	    uplevel 1 $body
	}
    }
}

proc restarter-starting-plan-hook {} {
    global wasfree
    catch { unset wasfree }
    for-free-resources freeres {
	set wasfree($freeres) 1
    }
}

proc restarter-maybe-provoke-restart {} {
    set newly_free {}
    global wasfree
    for-free-resources freeres {
	if {[info exists wasfree($freeres)]} continue
	lappend newly_free $freeres
	set wasfree($freeres) 1
    }
    if {![llength $newly_free]} {
	log-event "restarter-maybe-provoke-restart nothing"
	return
    }
 
    walker-globals plan

    if {!([info exists queue_running] && [llength $queue_running])} {
	log-event "restarter-maybe-provoke-restart not-running ($newly_free)"
	return
    }
    
    log-event "restarter-maybe-provoke-restart provoked ($newly_free)"

    if {[string compare RESTART [lindex $queue_running 0]]} {
	set queue_running [concat RESTART $queue_running]
    }
    after idle queuerun-perhaps-step plan
}

proc restarter-restart-now {} {
    # We restart the `plan' walker.  Well, actually, if the
    # `projection' walker is not running, we transfer the `plan'
    # walker to it.  At this stage the plan walker is not thinking so
    # there are no outstanding callbacks to worry about.

    log-event restarter-restart-now

    global projection/queue_running
    global plan/queue_running

    if {![info exists projection/queue_running]} {
	log-event "restarter-restart-now projection-idle continue-as"
	set projection/queue_running [set plan/queue_running]
	file copy -force data-plan.pl data-projection.pl
	after idle queuerun-perhaps-step projection
    } else {
	log-event "restarter-restart-now projection-running"
    }

    catching-internally "setting unprocessed" {
	chans-note-unprocessed plan [set plan/queue_running]
    }
    report-plan plan plan

    unset plan/queue_running
    runneeded-ensure-will 2
}

proc chans-note-unprocessed {w chans} {
    set data {}
    foreach chan $chans {
	append data [chan-plan-info $chan] "\n"
    }
    exec ./ms-planner -w$w unprocessed << $data
}

proc notify-to-think {w thinking} {
    for-chan $thinking {
	set noalloc [chan-get-info $thinking {$info(feature-noalloc)} {}]
	switch -glob $w.$noalloc {
	    plan.* { puts-chan $thinking "!OK think" }
	    projection.1 { puts-chan $thinking "!OK think noalloc" }
	    projection.* {
		# oh well, can't include it in the projection; too bad
		chans-note-unprocessed $w [list $thinking]
		queuerun-step-done $w "!feature-noalloc"
	    }
	}
    }
}

#---------- general stuff ----------

proc banner {chan} {
    return "OK ms-queuedaemon"
}

proc cmd/set-info {chan desc var val} {
    upvar #0 chan-info/$chan info
    set info($var) $val
    puts-chan $chan "OK set-info"
}
proc cmd/unset-info {chan desc var} {
    upvar #0 chan-info/$chan info
    catch { unset info($var) }
    puts-chan $chan "OK unset-info"
}

proc cmd/time {chan desc} {
    puts-chan $chan "OK time [clock seconds]"
}

proc chan-get-info {chan expr default} {
    upvar #0 chan-info/$chan info
    set val $default
    catch { set val [expr $expr] }
    return $val
}

proc cmd/wait {chan desc} {
    global queue need_queue_run
    lappend queue $chan

    upvar #0 chan-info/$chan info
    set "info(wait-start use)" [chan-get-info $chan {int($info(wait-start))} \
                                    [clock seconds]]

    set sortq {}
    foreach chan $queue { lappend sortq [list [chan-order-key $chan] $chan] }
    set sortq [lsort $sortq]
    set queue {}
    foreach item $sortq { log "QI $item"; lappend queue [lindex $item 1] }

    puts-chan $chan "OK wait"
    runneeded-ensure-polling
    runneeded-ensure-will 2
}

proc chans-compare-ordering {ca cb} {
    return [string compare [chan-ordering-key $cb] - [chan-ordering-key $ca]]
}
proc chan-order-key {chan} {
    upvar #0 chan-info/$chan info

    set priority [chan-get-info $chan {int($info(priority))} 0]
    set subpriority [chan-get-info $chan {int($info(sub-priority))} 0]

    set waitstart "$info(wait-start use)"
    incr waitstart [chan-get-info $chan {int($info(wait-start-adjust))} 0]

    #puts stderr "priority $chan $priority $emsg"
    return [format "%011d.%011d.%011d" \
                [expr {$priority+1000000000}] \
                [expr {$subpriority+1000000000}] \
                $waitstart]
}

proc cmd/prod {chan desc} {
    puts-chan $chan "OK prod"
    runneeded-ensure-will 2
}

proc cmd/inhibit {chan desc seconds why} {
    set seconds [expr {int($seconds)}]
    if {$seconds > 1000} { set seconds 1000 }
    add-inhibit "$desc $why" $seconds
    puts-chan $chan "OK inhibit $seconds"
}

proc cmd/uninhibit {chan desc} {
    global inhibit
    set was $inhibit
    set inhibit 0
    log "inhibition admin cancel!"
    runneeded-ensure-will 2
    puts-chan $chan "OK uninhibit $was"
}

proc cmd/uptime {chan desc seconds} {
    set before [expr {[clock seconds] - $seconds}]
    set descpat "[regsub {\:\d+$} $desc {:%}]"
    transaction resources {
        set keys {}
        pg_execute -array task dbh "
            SELECT * FROM tasks
                    WHERE type = 'ownd'
                      AND ( refkey LIKE [pg_quote $descpat]
                         OR refkey LIKE ('previous ' || [pg_quote $descpat]) )
                      AND live
                      AND refinfo IS NOT NULL
        " {
            set id "$task(taskid) $task(type) $task(refkey) $task(refinfo)"
            if {[catch { set refinfo [expr {int($task(refinfo))}] } emsg]} {
                puts-chan $chan "!WARNING uptime bad-refinfo $id"
                continue
            }
            if {$refinfo > $before} continue
            pg_execute dbh "
                UPDATE tasks
                   SET live = false,
                       refinfo = refinfo || ' stale'
                 WHERE taskid = $task(taskid)
            "
            puts-chan $chan "!OK uptime killed $id"
        }
    }
    puts-chan $chan "OK uptime"
}

proc bgerror {emsg} {
    global errorInfo errorCode
    puts stderr "****ERROR***\n$errorCode\n$emsg\n==========\n$errorInfo\n"
    exit 1
}

proc await-endings-notified {} {
    global owndchan
    while {[gets $owndchan l] > 0} {
        puts-chan-desc $owndchan "<< $l"
        if {![regexp {^!OK await-endings notify} $l]} {
            error "unexpected $l ?"
        }
        if {[eof $owndchan]} {
            error "$owndchan eof"
        }
        runneeded-ensure-will 2
        restarter-maybe-provoke-restart
    }
}

proc end-inhibit {why} {
    global inhibit
    incr inhibit -1
    log "inhibition $why: over, now $inhibit"
    if {$inhibit<=0} {
        set inhibit 0
        runneeded-ensure-will 2
    }
}    

proc add-inhibit {why seconds} {
    global inhibit
    after [expr {$seconds * 1000}] [list end-inhibit $why]
    incr inhibit
    log "inhibition $why: starts, ${seconds}s, now $inhibit"
}

main-daemon Queue {
    global owndchan chandesc inhibit plan
    
    jobdb::db-open

    set plan {}
    set queue {}
    set need_queue_run 0
    set inhibit 0

    log-state main-daemon
    # 1: run queue only if new resources available
    # 2: definitely run queue

    set owndchan [socket $c(OwnerDaemonHost) $c(OwnerDaemonPort)]
    fconfigure $owndchan -buffering line -translation lf
    set chandesc($owndchan) ownd
    
    must-gets-chan $owndchan {^OK ms-ownerdaemon}
    puts-chan $owndchan await-endings
    must-gets-chan $owndchan {^OK await-endings}

    fconfigure $owndchan -blocking false
    fileevent $owndchan readable await-endings-notified

    add-inhibit startdelay [expr {$c(QueueDaemonRetry) * 2}]

    runneeded-2-requeue
}
