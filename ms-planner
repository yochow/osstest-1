#!/usr/bin/perl
#
# this script has no locking; it expects to be called only
# from ms-queuedaemon

use strict qw(vars refs);
use DBI;
use Osstest;
use JSON;
use POSIX;
use Data::Dumper;
use HTML::Entities;

open DEBUG, ">/dev/null" or die $!;

while (@ARGV and $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--$/;
    while (m/^-./) {
        if (s/^-D/-/) {
            open DEBUG, ">&STDERR" or die $!;
        } else {
            die "$_ ?";
        }
    }
}

csreadconfig();

sub allocations ($) {
    my ($each) = @_;
    my $q= $dbh_tests->prepare(<<END);
        SELECT * FROM resources
	        WHERE owntaskid !=
		     (SELECT taskid FROM tasks
                       WHERE type='magic' AND refkey='allocatable')
END
    $q->execute();
    while (my $row= $q->fetchrow_hashref()) {
	my $reskey= join " ", map { $row->{$_} } qw(restype resname shareix);
	$each->($reskey, $row);
    }
    $q->finish();
}

our ($plan);

my $fn= "data-plan.pl";

sub get_current_plan () {
    if (!open P, $fn) {
	die $! unless $!==&ENOENT;
	$plan= { Allocations=>{ }, Bookings=>{ } };
	return;
    }
    local $/;
    my $plandump= <P>;
    P->error and die $!;
    close P or die $!;
    $plan= eval $plandump;
}

sub write_new_plan () {
    my $f= new IO::File "$fn.new", 'w' or die $!;
    my $d= new Data::Dumper([$plan]);
    $d->Terse(1);
    print $f $d->Dump() or die $!;
    close $f or die $!;
    rename "$fn.new",$fn or die $!;
}

sub cmd_reset () {
    die if @ARGV;

    get_current_plan();

    $plan->{Bookings}= { };
    $plan->{Start}= time;

    # get rid of now-freed allocations and look for any rogue allocations:
    my %current;
    allocations(sub {
	my ($reskey, $arow) = @_;
	$current{$reskey}= 1;

	my $alloc= $plan->{Allocations}{$reskey};
	next if defined $alloc;

	# rogue allocation!
	my $endtime= $plan->{Start} + $c{PlanRogueAllocationDuration};
	print STDERR "rogue $reskey: $arow->{owntaskid} $endtime\n" or die $!;
	$plan->{Allocations}{$reskey}= {
	    Info => "rogue task $arow->{owntaskid} $arow->{subtask}",
	    Start => $plan->{Start},
	    PlanEnd => $endtime,
	    ExptEnd => $endtime,
	};
    });
    foreach my $reskey (keys %{ $plan->{Allocations} }) {
	next if $current{$reskey};
	delete $plan->{Allocations}{$reskey};
    }

    # compute new expected finishing times:
    while (my ($reskey,$alloc) = each %{ $plan->{Allocations} }) {
	my $untilend_exptd= $alloc->{PlanEnd} - $plan->{Start};
	if ($untilend_exptd <= 0) {
	    my $duration_sofar= $plan->{Start} - $alloc->{Start};
	    my $duration_planned= $alloc->{PlanEnd} - $alloc->{Start};
	    my $duration_exptd=
		$duration_sofar * $duration_sofar / $duration_planned;
	    # we square the error - ie, we expect it to take
	    # longer than it has done so far by the proportion
	    # by which it has so far exceeded the original estimate
	    $untilend_exptd= $alloc->{Start} + ceil($duration_exptd);
	    die unless $untilend_exptd >= 0;
	    print STDERR "readjust $reskey: $duration_planned".
		" < $duration_sofar $untilend_exptd\n" or die $!;
	}
	$alloc->{ExptEnd}= $untilend_exptd + $plan->{Start};
    }

    write_new_plan();
}

sub cmd_get_plan () {
    die if @ARGV;

    get_current_plan();

    my $jplan= { Allocations=>{}, Bookings=>{} };
    while (my ($reskey,$alloc) = each %{ $plan->{Allocations} }) {
	$jplan->{Allocations}{$reskey}= {
	    End => $alloc->{ExptEnd} - $plan->{Start},
	};
    }
    while (my ($reskey,$books) = each %{ $plan->{Bookings} }) {
	next unless @$books;
	my @jbooks;
	foreach my $book (@$books) {
	    push @jbooks, {
		Start => $book->{Start} - $plan->{Start},
		End   => $book->{End}   - $plan->{Start},
	    };
	}
	$jplan->{Bookings}{$reskey}= \@jbooks;
    }
    print to_json($jplan),"\n" or die $!;
}

sub parse_reskey ($) {
    my ($rk) = @_;
    die unless defined $rk;
    die if ref $rk;
    die if $rk =~ m,[^-+_.!*%(){}:\#/0-9a-zA-Z],;
    return $rk;
}

sub parse_xinfo ($$) {
    my ($baseinfo,$xi) = @_;
    return $baseinfo unless defined $xi;
    die if ref $xi;
    die if $xi =~ m/[^[:ascii:]]/;
    die if $xi =~ m/[^[:print:]]/;
    return "$baseinfo $xi";
}

sub parse_reltime2abs ($) {
    my ($rt) = @_;
    die unless defined $rt;
    die if ref $rt;
    die unless $rt =~ m/^(0|[1-9][0-9]{0,8})$/;
    return $1 + $plan->{Start};
}

sub cmd_book_resources () {
    die unless @ARGV==1;
    my ($baseinfo) = @ARGV;
    
    local ($/)= undef;
    my $bookingsdata= <STDIN>;
    my $jbookings= from_json($bookingsdata);

    get_current_plan();

    die unless $jbookings->{Allocations};
    die unless $jbookings->{Bookings};

    foreach my $jbook (@{ $jbookings->{Allocations} }) {
	my $reskey= parse_reskey($jbook->{Reskey});
	die if $plan->{Allocations}{$reskey};
	my $endtime= parse_reltime2abs($jbook->{End});
	die unless $endtime > $plan->{Start};
	$plan->{Allocations}{$reskey}= {
	    Info => parse_xinfo($baseinfo, $jbook->{Xinfo}),
	    Start => $plan->{Start},
	    PlanEnd => $endtime,
	    ExptEnd => $endtime,
	};
    }

    foreach my $jbook (@{ $jbookings->{Bookings} }) {
	my $starttime= parse_reltime2abs($jbook->{Start});
	my $endtime= parse_reltime2abs($jbook->{End});
	die unless $endtime > $starttime;
	push @{ $plan->{Bookings}{ parse_reskey($jbook->{Reskey}) } }, {
	    Info => parse_xinfo($baseinfo, $jbook->{Xinfo}),
	    Start => $starttime,
	    End => $endtime,
	};
    }

    # sort the bookings list and check no double booking
    foreach my $reskey (keys %{ $plan->{Bookings} }) {
	print DEBUG "new bookings $reskey\n";
	my @books= sort { $a->{Start} <=> $b->{Start} }
	    @{ $plan->{Bookings}{$reskey} };
	my $alloc= $plan->{Allocations}{$reskey};
	my $last_end= defined($alloc) ? $alloc->{ExptEnd} : $plan->{Start};
	print DEBUG "  last_end $last_end\n";
	foreach my $book (@books) {
	    print DEBUG "  $book->{Start} $book->{End} $book->{Info}\n";
	    $book->{Start} >= $last_end
		or die "$reskey $book->{Start} $last_end";
	    $last_end= $book->{End};
	}
	$plan->{Bookings}{$reskey}= \@books;
    }

    write_new_plan();
}

sub show_rel_time ($) {
    my ($abs) = @_;
    my $rel= $abs - $plan->{Start};
    my $minus= $rel < 0 ? '-' : '';
    $rel= -$rel if $minus;
    my $mins= $rel % 60;   $rel -= $mins;   $rel /= 60;
    my $hours= $rel % 60;  $rel -= $hours;  $rel /= 60;
    sprintf "%s%d:%02d:%02d", $minus, $rel, $hours, $mins;
}

sub cmd_show_html () {
    get_current_plan();
    my $now= time;

    foreach my $books (values %{ $plan->{Bookings} }) {
	$_->{Type}= Booking foreach @$books;
    }
    
    my $earliest= $plan->{Start};
    while (my ($reskey,$alloc) = each %{ $plan->{Allocations} }) {
	unshift @{ $plan->{Bookings}{$reskey} }, {
	    %$alloc,
	    Type => Allocation,
	    End => $alloc->{PlanEnd},
	};
	if ($alloc->{ExptEnd} > $alloc->{PlanEnd}) {
	    unshift @{ $plan->{Bookings}{$reskey} }, {
		%$alloc,
		Type => Overrun,
		Start => $alloc->{PlanEnd},
		End => $alloc->{ExptEnd},
	    };
	}
	my $earlybook= $plan->{Bookings}{$reskey}[0];
	$earliest= $earlybook->{Start} if
	    $earlybook && $earlybook->{Start} < $earliest;
    }
    my @colheads = sort keys %{ $plan->{Bookings} };

    print DEBUG Dumper($earliest, $plan->{Bookings});

    my @outcols;
    foreach my $reskey (@colheads) {
	my @incol;
	my $dopush= sub {
	    my ($ni) = @_;
	    if ($incol[-1]{Start} == $ni->{Start}) {
		pop @incol;
	    }
	    $ni->{Rowspan}=1;
	    push @incol, $ni;
	};

	push @incol, { Type=>Idle, Info=>"", Rowspan=>1, Start=>$earliest };

	foreach my $booking (@{ $plan->{Bookings}{$reskey} }) {
	    $dopush->({ %$booking });
	    $dopush->({ Type=>Idle, Info=>"", Start => $booking->{End} });
	}
	push @incol, { Type=>Infinity, Start=>Inf };

	my @outcol;
	foreach (my $ix=0; $ix<@incol-1; $ix++) {
	    push @outcol, {
		Start => $incol[$ix]{Start},
		End => $incol[$ix+1]{Start},
		Content => $incol[$ix],
	    };
	}
	push @outcols, \@outcol;
    }

    my @rows;
    my (@newoutcols) = map { [] } @outcols;
    for (;;) {
	print DEBUG "==========\n", Dumper(\@outcols);
	    
	my $firstend= Inf;
	my $anystart= undef;
	foreach my $col (@outcols) {
	    my $cell= $col->[0];
	    $firstend= $cell->{End} if $cell->{End} < $firstend;
	    $anystart= $cell->{Start} if !defined $anystart;
	    die unless $cell->{Start}==$anystart;
	}

	print DEBUG Dumper($anystart, $firstend);

	foreach (my $colix=0; $colix<@outcols; $colix++) {
	    my $col= $outcols[$colix];
	    my $cell= shift @$col;
	    if ($cell->{End} != $firstend) {
		unshift @$col, { %$cell, Start=>$firstend };
		$cell = { %$cell, End=>$firstend },
		$cell->{Content}{Rowspan}++;
	    }
	    push @{ $newoutcols[$colix] }, $cell;
	}
	push @rows, { Start => $anystart, End => $firstend };

	last if $firstend == Inf;
    }

    print DEBUG "==============================\n",
        Dumper(\@rows, \@newoutcols);

    printf "<table rules=all><tr><td>plan age %s</td>\n", show_rel_time($now);
    foreach my $ch (@colheads) {
	printf "<th>%s</th>", encode_entities($ch);
    }
    print "</tr>\n";

    foreach my $event (@rows) {
	printf "<tr><th>%s</th>", show_rel_time($event->{Start});
	foreach my $col (@newoutcols) {
	    my $cell= shift @$col;
	    my $content= $cell->{Content};
	    if (!$content->{Printed}) {
		printf "<td rowspan=%d>%s %s</td>",
		    $content->{Rowspan},
		    $content->{Type},
		    encode_entities($content->{Info});
		$content->{Printed}= 1;
	    }
	}
	printf "</tr>\n";
    }
    printf "</table>\n";
}

die unless @ARGV;
die if $ARGV[0] =~ m/^-/;
my $subcmd= shift @ARGV;
$subcmd =~ s/-/_/g;
die if @ARGV && $ARGV[0] =~ m/^-/;
my $subcmdproc;
{
    $subcmdproc= \&{ "cmd_$subcmd" };
}
$subcmdproc->();
