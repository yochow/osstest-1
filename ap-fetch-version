#!/bin/bash

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


set -e -o posix

branch=$1
. ./cri-lock-repos
. ./cri-common
select_xenbranch
. ./ap-common

check_ap_fetch_placeholders

if info_linux_tree "$branch"; then
	repo_tree_rev_fetch_git linux \
		$TREE_LINUX_THIS $TAG_LINUX_THIS $LOCALREV_LINUX
	exit 0
fi

case "$branch" in
xen-3.*)
	./sg-hg-heads sh -ec '
		cd "'"$repos/$branch.hg"'"
	        hg pull -u >&2
	        eval "$1"
	' x
	;;
xen-unstable)
	repo_tree_rev_fetch_git xen $TREE_XEN smoke $LOCALREV_XEN
	;;
xen-unstable-smoke)
	repo_tree_rev_fetch_git xen $TREE_XEN staging $LOCALREV_XEN
	;;
xen-4.*-testing)
	branchcore=${branch#xen-}
	branchcore=${branchcore%-testing}
	repo_tree_rev_fetch_git xen \
		$TREE_XEN staging-$branchcore $LOCALREV_XEN
	;;
qemu-mainline)
	repo_tree_rev_fetch_git $branch \
		$TREE_QEMU_MAINLINE master $LOCALREV_QEMU_UPSTREAM
	;;
qemu-upstream-unstable)
        repo_tree_rev_fetch_git $branch \
		$TREE_QEMU_UPSTREAM staging $LOCALREV_QEMU_UPSTREAM
        ;;
qemu-upstream-*-testing)
	branchcore=${branch#qemu-upstream-}
	branchcore=${branchcore%-testing}
        repo_tree_rev_fetch_git $branch \
		$TREE_QEMU_UPSTREAM staging-$branchcore $LOCALREV_QEMU_UPSTREAM
        ;;
linux)
	repo_tree_rev_fetch_git linux \
		$TREE_LINUX $TAG_LINUX $LOCALREV_LINUX
	;;
linux-2.6.39)
	repo_tree_rev_fetch_git linux \
		$TREE_LINUX2639 $TAG_LINUX2639 $LOCALREV_LINUX
	;;
linux-xen-*)
	repo_tree_rev_fetch_git linux \
		$TREE_LINUX xen/next-${branch#linux-xen-} $LOCALREV_LINUX
	;;
linuxfirmware)
	repo_tree_rev_fetch_git linuxfirmware \
		$UPSTREAM_TREE_LINUXFIRMWARE master daily-cron.$branch
	;;
libvirt)
	repo_tree_rev_fetch_git libvirt \
		$TREE_LIBVIRT master $LOCALREV_LIBVIRT
	;;
rumpuserxen)
	repo_tree_rev_fetch_git rumpuserxen \
		$TREE_RUMPUSERXEN master $LOCALREV_RUMPUSERXEN
	;;
seabios)
	repo_tree_rev_fetch_git seabios \
		$TREE_SEABIOS_UPSTREAM master $LOCALREV_SEABIOS
	;;
ovmf)
	repo_tree_rev_fetch_git ovmf \
		$TREE_OVMF_UPSTREAM master $LOCALREV_OVMF
	;;
osstest)
        if [ "x$OSSTEST_USE_HEAD" = "xy" ] ; then
	    git update-ref -m "Arranging to test HEAD" \
		ap-fetch HEAD^0
	elif [ x"$TREEBRANCH_OSSTEST_UPSTREAM" != x ] ; then
	    # Deciding what to test here is somewhat complex because
	    # we would prefer to avoid octopus merges and to try and
	    # keep the change history as clean as reasonably possible.
	    #
	    # Therefore we prefer to test anything which is in local
	    # pretest before testing anything which is in
	    # upstream. Whether or not there is anything in local
	    # pretest is determined by using "git merge base"

	    git fetch $HOME/testing.git +production:production >&2
	    git fetch $HOME/testing.git +pretest:pretest >&2

	    local_production=$(git rev-parse production^0)
	    local_pretest=$(git rev-parse pretest^0)

	    merge_base=$(git merge-base $local_production $local_pretest)

	    echo >&2 "Considering merge from upstream"
	    echo >&2 "Local production: $local_production"
	    echo >&2 "Local pretest:    $local_pretest"
	    echo >&2 "Merge base:       $merge_base"

	    if [ x$merge_base = x$local_pretest ] ; then
		# local production is a ff of local pretest
		# (i.e. there is nothing local to test). So merge from
		# upstream master into production and test that.

		revision_merge=`repo_tree_rev_fetch_git osstest \
		    $TREEBRANCH_OSSTEST_UPSTREAM daily-cron.$branch`
		echo >&2 "Testing $TREEBRANCH_OSSTEST_UPSTREAM = $revision_merge"

		rm -rf $repos/osstest-merge >&2
		git clone -b production $HOME/testing.git $repos/osstest-merge >&2

		(
		    cd $repos/osstest-merge
		    git fetch $repos/osstest daily-cron.$branch:ap-merge >&2
		    git merge \
			-m "Automerge of $TREEBRANCH_OSSTEST_UPSTREAM into production" \
			ap-merge >&2
		    merge=$(git log -n1 --pretty='%T %P' HEAD)

		    if git fetch $HOME/testing.git +merge-epoch:merge-epoch >&2 ; then
			# If the new merge matches the current epoch's
			# tree (%T) and parents (%P) then it is the
			# same in all the ways which matter. (It
			# likely only differs in the date). In which
			# case reuse the epoch merge so that repeated
			# flights and potential bisections over
			# osstest see something stable.
			#
			# If e.g the parents have changed
			# (e.g. upstream has progressed) or the trees
			# differ then use the new merge and establish
			# a new merge-epoch.
			epoch=$(git log -n1 --pretty='%T %P' merge-epoch)
		    else
			echo >&2 "Failed to fetch merge-epoch"
			epoch="NONE"
		    fi

		    echo >&2 "Merge Epoch: $epoch"
		    echo >&2 "This Merge:  $merge"
		    if [ x"$epoch" = x"$merge" ] ; then
			echo >&2 "Reusing existing merge-epoch"
			git reset --hard merge-epoch >&2
		    else
			echo >&2 "New merge-epoch"
			git push $HOME/testing.git +production:merge-epoch >&2
		    fi
		)

		# Fetch the result of the above merge into local tree
		# ready for use. cr-daily-branch handles reseting the
		# working tree to this version
		git fetch $repos/osstest-merge +production:ap-fetch >&2
	    elif [ x$merge_base = x$local_production ] ; then
		# there are commits in pretest which we should test in
		# an attempt to progress production to this point.
		echo >&2 "Testing local pretest"
		git update-ref -m "Arranging to test local pretest" \
		    refs/heads/ap-fetch $local_pretest
	    else
		# It's too hard for to deal with automatically. This
		# might happen if a push to pretest races with a
		# successful flight which merges from upstream. We
		# expect pushes to pretest to be rare in practice.
		echo >&2 "************************************************"
		echo >&2 "production and pretest have diverged."
		echo >&2 "need manual fixup/rebase and push to pretest."
		echo >&2 "************************************************"
	    fi
	else
	    git fetch $HOME/testing.git pretest:ap-fetch >&2
	fi

	git rev-parse ap-fetch^0
        ;;
*)
	echo >&2 "branch $branch ?"
	exit 1
	;;
esac
