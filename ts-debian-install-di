#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict qw(vars);
use DBI;
use Osstest;
use Osstest::Debian;
use Osstest::TestSupport;

tsreadconfig();

our ($whhost,$gn,$flav) = @ARGV;
$whhost ||= 'host';
$gn ||= 'debian';
$flav ||= 'netboot';

our $ho= selecthost($whhost);

our $ram_mb=    512;
our $disk_mb= 10000;

our $guesthost= "$gn.guest.osstest";
our $gho;

sub prep () {
    target_install_packages_norec($ho, qw(lvm2));

    $gho= prepareguest($ho, $gn, $guesthost, 22,
                       $disk_mb, 40);

    prepareguest_part_lvmdisk($ho, $gho, $disk_mb);

    target_cmd_root($ho, "umount $gho->{Lvdev} ||:");
}

sub setup_netinst($$$)
{
    my ($didir, $arch, $cd) = @_;
    my %arch_props = (
	amd64 => { PathArch => "multi-arch", FileArch => "amd64-i386", IsoPath => "/install.amd/xen" },
	i386  => { PathArch => "multi-arch", FileArch => "amd64-i386", IsoPath => "/install.386/xen" },
	armhf => { PathArch => "armhf",      FileArch => "armhf",      IsoPath => "/install.armhf" }
    );
    my $props = $arch_props{$arch} or die "Unknown arch $arch";

    target_install_packages($ho, qw(jigdo-file));

    my $baseurl = $cd eq "current" ?
      "http://cdimage.debian.org/debian-cd/current/$props->{PathArch}/jigdo-cd" :
      "http://cdimage.debian.org/cdimage/weekly-builds/$props->{PathArch}/jigdo-cd";

    my $filebase;

    # Use the MD5SUMs file as an index
    logm("Fetch index from $baseurl/MD5SUMS");
    open C, "curl $baseurl/MD5SUMS|" or die "curl: $!";
    while(<C>) {
	m/^[0-9a-f]{32}  (debian-.*-$props->{FileArch}-netinst)\.iso$/ or next;
	$filebase = $1;
	last;
    }
    close(C);

    die unless $filebase;

    logm("Downloading $baseurl/$filebase.jigdo");
    # Jigdo seems to use /etc/apt/sources.list or something, so this
    # just works using the already configured mirror without
    # additional configuration, which is good because there doesn't
    # seem to be any support for such things, at least in Squeeze.
    my $netinst_jigdo = "$baseurl/$filebase.jigdo";
    target_cmd_root($ho, <<END);
    cd $didir && jigdo-lite --noask $netinst_jigdo
END
    store_runvar("$gho->{Guest}_netinst_jigdo", $netinst_jigdo);

    return (<<END, "\"file:$didir/$filebase.iso,xvdd:cdrom,r\",");
bootloader = "pygrub"
bootloader_args = ["--kernel=$props->{IsoPath}/vmlinuz", "--ramdisk=$props->{IsoPath}/initrd.gz"]
END
}

sub setup_netboot($$$)
{
    my ($didir, $arch, $suite) = @_;

    my $di_ver= $r{"$gho->{Guest}_diver"} || "current";

    my $mirror = "http://$c{DebianMirrorHost}/$c{DebianMirrorSubpath}";

    my $di_url = $suite eq "daily" ?
	"http://d-i.debian.org/daily-images/$arch/daily/netboot/xen" :
	"$mirror/dists/$suite/main/installer-$arch/$di_ver/images/netboot/xen";

    my $netboot_kernel = "$di_url/vmlinuz";
    my $netboot_initrd = "$di_url/initrd.gz";

    target_fetchurl($ho, $netboot_kernel, "$didir/kernel_${suite}_${arch}");
    target_fetchurl($ho, $netboot_initrd, "$didir/initrd_${suite}_${arch}");

    store_runvar("$gho->{Guest}_netboot_kernel", $netboot_kernel);
    store_runvar("$gho->{Guest}_netboot_initrd", $netboot_initrd);

    return <<END;
kernel      = "$didir/kernel_${suite}_${arch}"
ramdisk     = "$didir/initrd_${suite}_${arch}"
END
}
sub ginstall () {
    my $arch= $r{"$gho->{Guest}_arch"};
    my $method= $r{"$gho->{Guest}_method"};

    my $bl= $r{"$gho->{Guest}_bootloader"};

    target_cmd_root($ho, <<END);
rm -rf /root/di
mkdir /root/di
END

    my ($method_cfg, $ps_url, $extra_disk);

    if ( $method eq "netboot" )
    {
	my $suite= $r{"$gho->{Guest}_dist"};
	logm("$method $suite/$arch");

	$method_cfg = setup_netboot("/root/di", $arch, $suite);

	$suite = "sid" if $suite eq "daily";

	$ps_url = preseed_create_guest($gho, '', Suite=>$suite, PvMenuLst=>($bl eq "pvgrub"));

	$extra_disk = "";
    }
    elsif ($method eq "netinst" )
    {
	my $cd = $r{"$gho->{Guest}_cd"};

	logm("$method $cd/$arch");

	($method_cfg,$extra_disk) = setup_netinst("/root/di", $arch, $cd);

	$ps_url = preseed_create_guest($gho, '', CDROM=>1);
    }
    else
    {
	die "$method";
    }

    my $cmdline = join(" ", (
			   "debian-installer/exit/always_halt=true",
			   "--",
			   "console=hvc0",
			   "auto-install/enable=true",
			   "hostname=$gho->{Name}",
			   "domain=$c{TestHostDomain}",
			   "url=$ps_url",
			   "DEBIAN_FRONTEND=text",
			   "netcfg/dhcp_timeout=150",
			   "netcfg/choose_interface=eth0",
		       ));

    my $onreboot= 'restart';#$xopts->{OnReboot} || 'restart';
    my $vcpus= guest_var($gho, 'vcpus', 2);#$xopts->{DefVcpus} || 2);
    my $install_cfg= <<END;
name        = '$gho->{Name}'
memory      = ${ram_mb}
#
$method_cfg
extra       = "$cmdline"
#
vif         = [ 'mac=$gho->{Ether}' ]
#
on_poweroff = 'preserve'
on_reboot   = '$onreboot'
on_crash    = 'preserve'
#
vcpus = $vcpus
#
disk        = [
            $extra_disk 'phy:$gho->{Lvdev},xvda,w'
            ]
#
#\$cfgrest
#
#\$xoptcfg
END

    my $cfgpath= "/etc/xen/$gho->{Name}.cfg";

    $gho->{CfgPath}= $cfgpath;
    store_runvar("$gho->{Guest}_cfgpath", "$cfgpath");
    target_putfilecontents_root_stash($ho,30,$install_cfg, $cfgpath);

    my $cmd= toolstack()->{Command}." create ".
        $r{ $gho->{Guest}.'_'. toolstack()->{CfgPathVar} };
    target_cmd_root($ho, $cmd, 300);

    guest_checkrunning($ho, $gho) or die "$gho->{Name} not running";

    guest_await_shutdown($ho,$gho,2000);
    guest_destroy($ho,$gho);

    my $pvgrub = {
	i386 => "/usr/local/lib/xen/boot/pv-grub-x86_32.gz",
	amd64 => "/usr/local/lib/xen/boot/pv-grub-x86_64.gz"
    };
    my $blcfg = $bl eq "pvgrub" ? <<END : <<END;
kernel = "$pvgrub->{$arch}"
extra = "(hd0,0)/boot/grub/menu.lst"
END
bootloader = "pygrub"
END

    my $runtime_cfg= <<END;
name        = '$gho->{Name}'
memory = ${ram_mb}
#
$blcfg
#
vif         = [ 'mac=$gho->{Ether}' ]
#
on_poweroff = 'destroy'
on_reboot   = '$onreboot'
on_crash    = 'preserve'
#
vcpus = $vcpus
#
disk        = [
            'phy:$gho->{Lvdev},xvda,w'
            ]
END

    target_putfilecontents_root_stash($ho,30,$runtime_cfg, $cfgpath);

    return;
}

prep();
ginstall();
