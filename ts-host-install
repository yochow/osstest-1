#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict qw(vars);
use DBI;
use POSIX;

use Osstest;
use Osstest::Debian;
use Osstest::TestSupport;
use Osstest::Logtailer;

tsreadconfig();

my $debconf_priority;
my $poweron_test_only;

our %xopts;

while (@ARGV and $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--$/;
    if (m/^--priority(?:=(.*))?$/) {
        $xopts{DebconfPriority}= defined($1) ? $1 : 'low';
    } elsif  (m/^--poweron-test-only$/) {
	$poweron_test_only= 1;
    } elsif  (m/^--rescue$/) {
	$xopts{RescueMode}= 1;
    } else {
	die "$_ $!";
    }
}

our ($whhost) = @ARGV;
$whhost ||= 'host';
our $ho= selecthost($whhost);
exit 0 if $ho->{Flags}{'no-reinstall'};
exit 0 if $ho->{SharedReady};

our %timeout= qw(ReadPreseed  350
                 Sshd        2400);

sub install () {
    power_state($ho, 0);

    my ($ps_url,$ps_file)= preseed_create
        ($ho, '',
         Suite => $ho->{Suite},
         DiskDevice => $ho->{DiskDevice},
         Properties => $ho->{Properties},
         ExtraPreseed => <<END );
d-i netcfg/get_hostname string $ho->{Name}
d-i netcfg/get_ipaddress string $ho->{Ip}
END

    setup_pxeboot_firstboot($ps_url);
    power_cycle_sleep($ho);

    my $logtailer= Osstest::Logtailer->new($c{WebspaceLog});
    power_state($ho, 1);

    await_webspace_fetch_byleaf(get_timeout($ho,'reboot',$timeout{ReadPreseed})
                                , 1,
                                $logtailer, $ho, $ps_url);

    if ($poweron_test_only) {
	logm("Hooray, power on worked.");
	power_state($ho, 0);
	exit 0;
    }

    setup_pxeboot_local($ho);

    await_tcp(get_timeout($ho,'reboot',$timeout{Sshd}), 14,$ho);

    our $vgname= $ho->{Name};

    if ($ho->{Suite} =~ m/lenny/) {
        $vgname .= ".$c{TestHostDomain}";
        target_editfile_root($ho, '/boot/grub/menu.lst', sub {
            while (<EI>) {
                s/^terminal.*/terminal --timeout=10 serial console/;
                print EO or die $!;
            }
        });
    }

    my $lvs= target_cmd_output_root($ho, 'lvdisplay --colon');
    foreach my $l (split /\n/, $lvs) {
        logm("| $l");
        next unless $l =~ m,^\s*(/dev/[^:]+/dummy):,;
        target_cmd_root($ho, "lvremove -f $1");
    }

    my $partitions= target_cmd_output_root($ho, 'cat /proc/partitions');
    foreach my $l (split /\n/, $partitions) {
        logm("| $l");
        next unless $l =~ m/^\s*\d+\s+\d+\s+\d+\s+((?:sd|hd)[b-z])\s*$/;
        my $dev= "/dev/$1";
        target_cmd_root($ho, "pvcreate $dev");
        target_cmd_root($ho, "vgextend $vgname $dev");
    }

    my $kpath= $c{TestHostKeypairPath};
    my $kleaf= $kpath;
    $kleaf =~ s,.*/,,;
    my $ktarg= $kleaf;
    $ktarg =~ s/^(id_[a-z]+)_.*/$1/;
    foreach my $ext ('', '.pub') {
	target_putfile     ($ho,10, "${kpath}${ext}", ".ssh/${ktarg}${ext}");
	target_putfile_root($ho,10, "${kpath}${ext}", ".ssh/${ktarg}${ext}");
    }
    target_cmd     ($ho, "chmod g-r .ssh/${ktarg}");
    target_cmd_root($ho, "chmod g-r .ssh/${ktarg}");

    target_cmd_root($ho, "chmod 2775 /root");

    target_install_packages($ho, qw(ed));

    my $ntpserver = get_target_property($ho, 'NtpServer');
    if ($ntpserver) {
	target_editfile_root($ho, '/etc/ntp.conf', sub {
	    my $done= 0;
	    while (<EI>) {
		if (m/^server\s/) {
		    if ($ho->{Suite} =~ m/lenny|squeeze|wheezy|jessie/) {
			$_= $done ? "" : "server $ntpserver\n";
		    } else {
			m/^server \Q$ntpserver\E\s/ or
			    die "NTP server not honoured, Debian #778564 ";
		    }
		    $done= 1;
		}
		print EO or die $!;
	    }
	    $done or die;
	});
    }

    target_cmd_root($ho, 'mkdir -p /var/core');
    target_editfile_root($ho, '/etc/sysctl.conf',
	sub { target_editfile_kvp_replace(
		  "kernel.core_pattern",
		  # %p==pid,%e==executable name,%t==timestamp
		  "/var/core/%t.%p.%e.core") });
    target_cmd_root($ho, "sysctl --load /etc/sysctl.conf");
    my $coredumps_conf = <<'END';
#<domain>      <type>  <item>       <value>
*               soft    core         -1
root            soft    core         -1
END
    target_putfilecontents_root_stash($ho,10,$coredumps_conf,
				'/etc/security/limits.d/coredumps.conf');

    target_cmd_root($ho, "update-rc.d osstest-confirm-booted start 99 2 .");

    logm('OK: install completed');
}   

sub setup_pxeboot_firstboot($) {
    my ($ps_url) = @_;
    
    my $d_i= $ho->{Tftp}{DiBase}.'/'.$r{arch}.'/'.$c{TftpDiVersion}.'-'.$ho->{Suite};
    
    my @installcmdline= qw(vga=normal);
    push @installcmdline, di_installcmdline_core($ho, $ps_url, %xopts);

    my $src_initrd= "$d_i/initrd.gz";
    my @initrds= "$ho->{Tftp}{Path}/$src_initrd";

    my $kernel;

    foreach my $fp (keys %{ $ho->{Flags} }) {
        $fp =~ s/^need-firmware-deb-// or next;
        my $cpio= "$ho->{Tftp}{Path}/$d_i/$fp.cpio.gz";
        if (stat $cpio) {
            logm("using firmware from: $cpio");
            push @initrds, $cpio;
        } elsif ($! == &ENOENT) {
            logm("warning: no firmware cpio found for $fp at $cpio");
        } else {
            die "$fp $cpio $!";
        }
    }

    foreach my $kp (keys %{ $ho->{Flags} }) {
        # Backwards compatibility
        $kp = "need-kernel-deb-wheezy-backports" if $kp eq "need-kernel-deb-armmp";
        $kp =~ s/need-kernel-deb-$ho->{Suite}// or next;
        my $kern= "$ho->{Tftp}{Path}/$d_i/linux.$kp";
        if (stat $kern) {
            logm("using kernel from: $kern");
            $kernel = "/$d_i/linux.$kp";
        } elsif ($! == &ENOENT) {
            logm("warning: no kernel found for $kp at $kern");
        } else {
            die "$kp $kern $!";
        }

        my $cpio= "$ho->{Tftp}{Path}/$d_i/$kp.cpio.gz";
        if (stat $cpio) {
            logm("using kernel modules from: $cpio");
            push @initrds, $cpio;
        } elsif ($! == &ENOENT) {
            logm("warning: no kernel module cpio found for $kp at $cpio");
        } else {
            die "$kp $cpio $!";
        }
    }

    $kernel = "/$d_i/linux" unless $kernel;

    my $initrd_overlay= "tmp/t.$ho->{Name}.initrd";
    system qw(rm -rf --),"$initrd_overlay.d";
    mkdir "$initrd_overlay.d" or die "$initrd_overlay.d: $!";

    my $ipappend = 2;
    my $wantphysif= get_host_property($ho,'interface force','auto');
    logm("Forcing interface $wantphysif");
    if ($wantphysif ne 'auto') {
	$ipappend = 0;
	die "need Ether for $ho->{Name} ($wantphysif)"
	    unless defined $ho->{Ether};
        system_checked(qw(mkdir -p --), "$initrd_overlay.d/etc/udev/rules.d");
        file_simple_write_contents
            ("$initrd_overlay.d/etc/udev/rules.d/70-persistent-net.rules",
             $ho->{Flags}{'force-mac-address'} ? <<END : <<END);
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", KERNEL=="$wantphysif", RUN += "/bin/ip link set $wantphysif address $ho->{Ether}"
END
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="$ho->{Ether}", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="$wantphysif"
END
    }

    my $dtbs = "";
    foreach my $kp (keys %{ $ho->{Flags} }) {
	# Backwards compatibility
	$kp = "need-kernel-deb-wheezy-backports" if $kp eq "need-kernel-deb-armmp";
	$kp =~ s/need-kernel-deb-$ho->{Suite}// or next;

	$dtbs = "fdtdir /$d_i/$kp-dtbs"
	    if -e "$ho->{Tftp}{Path}/$d_i/$kp-dtbs";
    }

    file_simple_write_contents("$initrd_overlay.cpio", sub {
        contents_make_cpio($_[0], 'newc', "$initrd_overlay.d");
    });

    system_checked(qw(gzip -1vf --), "$initrd_overlay.cpio");
    push @initrds, "$initrd_overlay.cpio.gz";

    logm("using initrds: @initrds");
    my $initrd= "$ho->{Tftp}{TmpDir}$ho->{Name}--initrd.gz";
    system_checked("cat -- @initrds >$ho->{Tftp}{Path}$initrd");
    
    push @installcmdline, ("initrd=/$initrd",
                           "domain=$c{TestHostDomain}",
                           );
    push @installcmdline,
        get_host_property($ho, "install-append $ho->{Suite}", ''),
        get_host_property($ho, "install-append $ho->{Suite} $r{arch}", '');

    my $console = get_host_native_linux_console($ho);

    push @installcmdline, "console=$console" unless $console eq "NONE";

    push @installcmdline, qw(--);

    # See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=762007 for
    # why this is repeated.
    push @installcmdline, "console=$console" unless $console eq "NONE";

    push @installcmdline,
        get_host_property($ho, "linux-boot-append $ho->{Suite}", ''),
        get_host_property($ho, "linux-boot-append $ho->{Suite} $r{arch}", '');

    my $installcmdline= join ' ', @installcmdline;

    setup_pxeboot($ho, <<END);
serial 0 $c{Baud}
timeout 5
label overwrite
	menu label ^Overwrite
	menu default
	kernel $kernel
	append $installcmdline
	ipappend $ipappend
	$dtbs
default overwrite
END
}

install();
