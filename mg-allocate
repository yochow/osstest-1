#!/usr/bin/perl -w
#
# resource syntax:
#   [!][<type>/]<name>[/<share>]      type defaults to 'host'
#                                     type=='S' means 'shared-host'
#                                     share defaults to *
#                                     - means deallocate

use strict qw(vars refs);
use DBI;
use Osstest;

csreadconfig();

sub execute () {
    my $tid= findtask();
    
    db_retry($dbh_tests, \@all_lock_tables, sub {

	my %magictask;
	foreach my $rk (qw(idle shared preparing allocatable)) {
	    my $row= $dbh_tests->selectrow_hashref(<<END,{}, $rk);
                SELECT * FROM tasks WHERE type='magic' AND refkey=?
END
            $magictask{$rk}= $row->{taskid};
        }

        my $allok=1;
        foreach my $res (@ARGV) {
            $res =~ m,^(\!?) (?: ([^/]+)/ )? ([^/]+) (?: /(\d+|\*) )?$,x
                or die "bad resource $res ?";
            my $allocate= !$1;
            my $restype= defined($2) ? $2 : 'host';
            $restype= 'shared-host' if $restype eq 'S';
            my $resname= $3;
            my $shareix= defined($4) ? $4+0 : '*';
            my $shareixcond = $shareix eq '*' ? '' : "AND shareix = $shareix";

            my $resq= $dbh_tests->prepare(<<END);
                SELECT * FROM resources r
                         JOIN tasks t
                           ON r.owntaskid=t.taskid
                        WHERE r.restype=? AND r.resname=? $shareixcond
                     ORDER BY (t.type='magic') DESC,
                              t.live ASC
END
            $resq->execute($restype, $resname);

            my $ok= 0;
            while (my $candrow= $resq->fetchrow_hashref()) {
                my $desc= "$candrow->{restype}/$candrow->{resname}".
                    "/$candrow->{shareix}";
                my $setres= sub {
                    my ($newtid) = @_;
                    my $ndone= $dbh_tests->do(<<END,{},
                        UPDATE resources
                           SET owntaskid=?, subtask=?
                         WHERE restype=? AND resname=? AND shareix=?
END
                           $newtid, "manual ".$res,
                           $restype,$resname,$candrow->{shareix});
                    $ndone==1 or die "$restype $resname $newtid $desc";
                };

		my $isallocatable= sub {
		    my ($joinedrow) = @_;
		    return
			!$joinedrow->{live} ||
			$joinedrow->{owntaskid}==$magictask{allocatable} ||
			$joinedrow->{owntaskid}==$magictask{idle};
		};
		my $findowner= sub {
		    my ($joinedrow) = @_;
		    my $owner= "$joinedrow->{owntaskid} $joinedrow->{type}".
			" $joinedrow->{refkey}";
		    foreach my $k (qw(username comment refinfo)) {
                        my $v= $candrow->{$k};
                        next unless defined $v;
                        ($v =~ s/[\"\\]/\\$&/g, $v="\"$v\"")
                            if $v =~ m/[^-+\@_.,0-9a-z]/;
                        $owner.= " $k=$v";
                    }
		    return $owner;
		};

		my $isshared=
		    $candrow->{owntaskid} == $magictask{shared};

		if ($isshared) {
		    my $shresq= $dbh_tests->prepare(<<END);
			SELECT * FROM resources r
				 JOIN tasks t
				   ON r.owntaskid=t.taskid
				WHERE r.restype=? AND r.resname=?
			     ORDER BY (t.type='magic') DESC,
				      t.live ASC
END
                    $shresq->execute("share-$restype", $resname);
		    my $allshareok= 1;
		    foreach (my $sharerow= $shresq->fetchrow_hashref()) {
			next if $isallocatable->($sharerow);
			next if $sharerow->{sharerow} == $tid;
			next if $sharerow->{sharerow} == $magictask{preparing};
			logm("$desc: shared, $sharerow->{shareix} locked by ".
			     $findowner->($sharerow));
			$allshareok= 0;
		    }
		    $shresq->finish();
		    next unless $allshareok;
		}

                if ($allocate) {
                    if ($candrow->{owntaskid} == $tid) {
                        logm("$desc: already allocated to $tid");
                        $ok=1; last;
                    }
		    if ($isshared) {
			logm("$desc: available, unsharing");
		    } elsif ($isallocatable->($candrow)) {
                        logm("$desc: available ($candrow->{refkey})");
                    } else {
                        logm("$desc: locked by ".$findowner->($candrow));
                        next;
                    }
                    $setres->($tid);
                } else {
		    if ($isshared) {
			logm("$desc: unsharing, freeing");
		    } elsif ($candrow->{owntaskid} != $tid) {
                        logm("$desc: locked by ".$findowner->($candrow));
                        next;
                    } else {
			logm("$desc: freeing");
		    }
                    $setres->($magictask{idle});
                }

		if ($isshared) {
		    $dbh_tests->do(<<END, {}, $restype,$resname);
		        DELETE FROM resource_sharing
			      WHERE restype = ? AND resname = ?
END
                    $dbh_tests->do(<<END, {}, "share-$restype",$resname);
		        DELETE FROM resources
			      WHERE restype = ? AND resname = ?
END
		}
		
		$ok=1; last;
            }
            if (!$ok) {
               logm("nothing available for $res, sorry");
               $allok=0;
           }
        }

        if (!$allok) {
            die "allocation/deallocation unsuccessful\n";
        }
    });
    logm("done.");
}

execute();
