#!/usr/bin/perl -w
#
# resource syntax:
#   [!][<type>/]<name>[/<share>]      type defaults to 'host'
#                                     type=='S' means 'shared-host'
#                                     share defaults to *
#                                     - means deallocate
#                                     name=option|option|... means
#                                       any one of those options
#                                     option={flag,flag...} means anything
#                                       with all those flags

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.



use strict qw(vars refs);
use DBI;
use Osstest;
use Osstest::TestSupport;
use Osstest::Executive;

csreadconfig();

our $tid;
our %magictask;

sub alloc_prep () {
    $tid= findtask();
    
    foreach my $rk (qw(idle shared preparing allocatable)) {
        my $row= $dbh_tests->selectrow_hashref(<<END,{}, $rk);
                SELECT * FROM tasks WHERE type='magic' AND refkey=?
END
        $magictask{$rk}= $row->{taskid};
    }
}

sub parse_1res ($) {
    my ($res) = @_;

    $res =~ m,^(\!?) (?: ([^/]+)/ )? ([^/]+) (?: /(\d+|\*) )?$,x
        or die "bad resource $res ?";
    my $allocate= !$1;
    my $restype= defined($2) ? $2 : 'host';
    $restype= 'share-host' if $restype eq 'S';
    my $resname= $3;
    my $shareix= defined($4) ? $4+0 : '*';
    my $shareixcond = $shareix eq '*' ? '' : "AND shareix = $shareix";

    my @resnames;
    foreach my $option (split /\|/, $resname) {
	if ($option =~ m/^\{(.*)\}$/) {
	    my $q = "SELECT resname FROM resources r WHERE restype = ?";
	    my @qa = ($restype);
	    die unless $restype eq 'host';
	    foreach my $flag (split /\,/, $1) {
		$q .= "\n AND EXISTS (SELECT 1 FROM hostflags h".
		    " WHERE h.hostname = r.resname AND h.hostflag = ?)";
		push @qa, $flag;
	    }
	    my $hosts = $dbh_tests->selectcol_arrayref($q, {}, @qa);
	    logm("for $option possibilities are: @$hosts");
	    push @resnames, @$hosts;
	} else {
	    push @resnames, $option;
	}
    }
    logm("for $resname all possibilities are: @resnames") if @resnames!=1;
    die "nothing for $resname" unless @resnames;

    return [ map {
	        [ $allocate, $restype, $_, $shareix, $shareixcond ]
	     } @resnames ];
}

sub alloc_1rescand ($$) {
    my ($res, $rescand) = @_;
    my ($allocate, $restype, $resname, $shareix, $shareixcond) = @$rescand;

    my $resq= $dbh_tests->prepare(<<END);
                SELECT * FROM resources r
                         JOIN tasks t
                           ON r.owntaskid=t.taskid
                        WHERE r.restype=? AND r.resname=? $shareixcond
                     ORDER BY (t.type='magic') DESC,
                              t.live ASC
END
    $resq->execute($restype, $resname);

    my $ok= 0;
    my $got_shareix = 'x';
    while (my $candrow= $resq->fetchrow_hashref()) {
        my $desc= "$candrow->{restype}/$candrow->{resname}".
            "/$candrow->{shareix}";

        my $setres= sub {
            my ($newtid) = @_;
            my $ndone= $dbh_tests->do(<<END,{},
                        UPDATE resources
                           SET owntaskid=?, subtask=?
                         WHERE restype=? AND resname=? AND shareix=?
END
                           $newtid, "manual ".$res,
                           $restype,$resname,$candrow->{shareix});
                    $ndone==1 or die "$restype $resname $newtid $desc";
        };

        my $isallocatable= sub {
            my ($joinedrow) = @_;
            return
                !$joinedrow->{live} ||
                $joinedrow->{taskid}==$magictask{allocatable} ||
                $joinedrow->{taskid}==$magictask{idle};
        };
        my $findowner= sub {
            my ($joinedrow) = @_;
            my $owner= "$joinedrow->{owntaskid} $joinedrow->{type}".
                       " $joinedrow->{refkey}";
            foreach my $k (qw(username comment refinfo)) {
                my $v= $joinedrow->{$k};
                next unless defined $v;
                next unless length $v;
                ($v =~ s/[\"\\]/\\$&/g, $v="\"$v\"")
                    if $v =~ m/[^-+\@_.,0-9a-z]/;
                $owner.= " $k=$v";
            }
            return $owner;
        };

        my $isshared=
            $candrow->{owntaskid} == $magictask{shared};

        if ($isshared) {
            my $shresq= $dbh_tests->prepare(<<END);
			SELECT * FROM resources r
				 JOIN tasks t
				   ON r.owntaskid=t.taskid
				WHERE r.restype=? AND r.resname=?
			     ORDER BY (t.type='magic') DESC,
				      t.live ASC
END
            $shresq->execute("share-$restype", $resname);
            my $allshareok= 1;
            while (my $sharerow= $shresq->fetchrow_hashref()) {
                next if $isallocatable->($sharerow);
                next if $sharerow->{taskid} == $tid;
                next if $sharerow->{taskid} == $magictask{preparing};
                logm("$desc: shared, $sharerow->{shareix} locked by ".
                     $findowner->($sharerow));
                $allshareok= 0;
            }
            $shresq->finish();
            next unless $allshareok;
        }

        if ($allocate) {
            if ($candrow->{owntaskid} == $tid) {
                logm("$desc: already allocated to $tid");
                $got_shareix= $candrow->{shareix};
                $ok=1; last;
            }
            if ($isshared) {
                logm("$desc: available, unsharing");
            } elsif ($isallocatable->($candrow)) {
                logm("$desc: allocating (was $candrow->{refkey})");
            } else {
                logm("$desc: locked by ".$findowner->($candrow));
                next;
            }
            $setres->($tid);
        } else {
            if ($isshared) {
                logm("$desc: unsharing, freeing");
            } elsif ($candrow->{owntaskid} != $tid) {
                logm("$desc: locked by ".$findowner->($candrow));
                next;
            } else {
                logm("$desc: freeing");
            }
            $setres->($magictask{idle});
        }

        if ($isshared) {
            $dbh_tests->do(<<END, {}, $restype,$resname);
		        DELETE FROM resource_sharing
			      WHERE restype = ? AND resname = ?
END
            $dbh_tests->do(<<END, {}, "share-$restype",$resname);
		        DELETE FROM resources
			      WHERE restype = ? AND resname = ?
END
        }

        $got_shareix= $candrow->{shareix};
        $ok=1; last;
    }
    return ($ok, { Allocate => $allocate,
		   Shareix => $got_shareix,
		   Info => "$resname ($restype/$resname/$got_shareix)"
	    });
}

sub alloc_1res ($) {
    my ($res) = @_;

    my $rescands = parse_1res($res);

    foreach my $rescand (@$rescands) {
	my @got = alloc_1rescand($res, $rescand);
	return @got if $got[0];
    }
    return (0,undef);
}

sub loggot {
    my @got = @_;
    logm(($_->{Allocate} ? "ALLOCATED" : "DEALLOCATED").": ".$_->{Info})
	foreach @got;
}

sub execute () {
    my @got;
    db_retry($dbh_tests, \@all_lock_tables, sub {

        alloc_prep();

        my $allok=1;
	@got = ();
        foreach my $res (@ARGV) {
            my ($ok, $got) = alloc_1res($res);
            if (!$ok) {
                logm("nothing available for $res, sorry");
                $allok=0;
            } else {
                logm("processed $res (shareix=$got->{Shareix})");
		push @got, $got;
            }
        }

        if (!$allok) {
            die "allocation/deallocation unsuccessful\n";
        }
    });
    loggot(@got);
    logm("done.");
}

our $duration; # seconds, undef means immediate ad-hoc

sub showposs ($) {
    my ($poss) = @_;
    join ' + ', map { $_->{Reso} } @$poss;
}

sub plan () {
    my @got;

    my $info = "manual ".manual_allocation_base_jobinfo();

    alloc_resources(JobInfo => $info, sub {
        my ($plan, $mayalloc) = @_;

	@got = ();
        my @possmatrix = ([]);

        foreach my $res (@ARGV) {
	    my $rescands = parse_1res($res);
	    my @reqlist;
	    foreach my $rescand (@$rescands) {
		my ($allocate, $restype, $resname, $shareix, $shareixcond) =
		    @$rescand;
		die "cannot plan deallocation" unless $allocate;
		die "cannot plan individual shares" unless $shareix eq '*';
		push @reqlist, {
		    Ident => "$res",
		    Reso => "$restype $resname",
		};
	    }
	    @possmatrix = map {
		my $possreqs = $_;
		map { [ @$possreqs, $_ ] } @reqlist;
	    } @possmatrix;
        }

	my $planned;
	my @reqlist;
	foreach my $poss (@possmatrix) {
	    my $tplanned= plan_search
		($plan, sub { print " @_\n"; }, $duration, $poss);
	    printf " possibility Start=%d %s\n",
	        $tplanned->{Start}, showposs($poss);
	    if (!$planned || $tplanned->{Start} < $planned->{Start}) {
		$planned = $tplanned;
		@reqlist = @$poss;
	    }
	}
	logm("best at $planned->{Start} is ".showposs(\@reqlist));
	die unless $planned;

        my $allok=0;
        if ($mayalloc && !$planned->{Start}) {
            $allok=1;

            alloc_prep();

            foreach my $req (@reqlist) {
                my ($ok, $got) = alloc_1res($req->{Ident});
                if (!$ok) {
                    logm("failed to allocate $req->{Ident}!");
                    $allok=0;
                } else {
                    $req->{GotShareix}= $got->{Shareix};
		    push @got, $got;
                }
            }
        }

        if ($allok) {
            logm("allocated, notifying...");
        } else {
            logm("booking...");
        }

        my @bookings;
        foreach my $req (@reqlist) {
            my $book= {
                Reso => $req->{Reso},
                Xinfo => $req->{Ident},
                Start => $planned->{Start},
                End => $planned->{Start} + $duration,
            };
            if ($allok) {
                $book->{Allocated}= {
                    Task => $tid,
                    Shareix => $req->{GotShareix},
                };
            }
            push @bookings, $book;
        }

        return ($allok, { Bookings => \@bookings });
    });
    loggot(@got);
}

while (@ARGV && $ARGV[0] =~ m/^[-0-9]/) {
    $_= shift @ARGV;
    last if m/^\-\-?$/;
    while (!m/^\-$/) {
        if (s/^(\d+)([dhms]?)$/-/) {
            $duration= $1 * ($2 eq 'd' ? 86400 :
                             $2 eq 'h' ?  3600 :
                             $2 eq 'm' ?    60 :
                                             1);
        } elsif (s/^\-U/-/) {
            $ENV{OSSTEST_RESOURCE_PRIORITY} //= -1000000;
        } else {
            die "bad option \`$_'";
        }
    }
}

if ($duration) {
    plan();
} else {
    execute();
}
