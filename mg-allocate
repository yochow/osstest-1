#!/usr/bin/perl -w
#
# resource syntax:
#   [!][<type>/]<name>[/<share>]      type defaults to 'host'
#                                     type=='S' means 'shared-host'
#                                     share defaults to *
#                                     - means deallocate

use strict qw(vars refs);
use DBI;
use Osstest;

csreadconfig();

our $tid;
our %magictask;

sub alloc_prep () {
    $tid= findtask();
    
    foreach my $rk (qw(idle shared preparing allocatable)) {
        my $row= $dbh_tests->selectrow_hashref(<<END,{}, $rk);
                SELECT * FROM tasks WHERE type='magic' AND refkey=?
END
        $magictask{$rk}= $row->{taskid};
    }
}

sub parse_1res ($) {
    my ($res) = @_;

    $res =~ m,^(\!?) (?: ([^/]+)/ )? ([^/]+) (?: /(\d+|\*) )?$,x
        or die "bad resource $res ?";
    my $allocate= !$1;
    my $restype= defined($2) ? $2 : 'host';
    $restype= 'shared-host' if $restype eq 'S';
    my $resname= $3;
    my $shareix= defined($4) ? $4+0 : '*';
    my $shareixcond = $shareix eq '*' ? '' : "AND shareix = $shareix";

    return ($allocate, $restype, $resname, $shareix, $shareixcond);
}

sub alloc_1res ($) {
    my ($res) = @_;

    my ($allocate, $restype, $resname, $shareix, $shareixcond) =
        parse_1res($res);
    
    my $resq= $dbh_tests->prepare(<<END);
                SELECT * FROM resources r
                         JOIN tasks t
                           ON r.owntaskid=t.taskid
                        WHERE r.restype=? AND r.resname=? $shareixcond
                     ORDER BY (t.type='magic') DESC,
                              t.live ASC
END
    $resq->execute($restype, $resname);

    my $ok= 0;
    while (my $candrow= $resq->fetchrow_hashref()) {
        my $desc= "$candrow->{restype}/$candrow->{resname}".
            "/$candrow->{shareix}";

        my $setres= sub {
            my ($newtid) = @_;
            my $ndone= $dbh_tests->do(<<END,{},
                        UPDATE resources
                           SET owntaskid=?, subtask=?
                         WHERE restype=? AND resname=? AND shareix=?
END
                           $newtid, "manual ".$res,
                           $restype,$resname,$candrow->{shareix});
                    $ndone==1 or die "$restype $resname $newtid $desc";
        };

        my $isallocatable= sub {
            my ($joinedrow) = @_;
            return
                !$joinedrow->{live} ||
                $joinedrow->{taskid}==$magictask{allocatable} ||
                $joinedrow->{taskid}==$magictask{idle};
        };
        my $findowner= sub {
            my ($joinedrow) = @_;
            my $owner= "$joinedrow->{owntaskid} $joinedrow->{type}".
                       " $joinedrow->{refkey}";
            foreach my $k (qw(username comment refinfo)) {
                my $v= $joinedrow->{$k};
                next unless defined $v;
                next unless length $v;
                ($v =~ s/[\"\\]/\\$&/g, $v="\"$v\"")
                    if $v =~ m/[^-+\@_.,0-9a-z]/;
                $owner.= " $k=$v";
            }
            return $owner;
        };

        my $isshared=
            $candrow->{owntaskid} == $magictask{shared};

        if ($isshared) {
            my $shresq= $dbh_tests->prepare(<<END);
			SELECT * FROM resources r
				 JOIN tasks t
				   ON r.owntaskid=t.taskid
				WHERE r.restype=? AND r.resname=?
			     ORDER BY (t.type='magic') DESC,
				      t.live ASC
END
            $shresq->execute("share-$restype", $resname);
            my $allshareok= 1;
            while (my $sharerow= $shresq->fetchrow_hashref()) {
                next if $isallocatable->($sharerow);
                next if $sharerow->{taskid} == $tid;
                next if $sharerow->{taskid} == $magictask{preparing};
                logm("$desc: shared, $sharerow->{shareix} locked by ".
                     $findowner->($sharerow));
                $allshareok= 0;
            }
            $shresq->finish();
            next unless $allshareok;
        }

        if ($allocate) {
            if ($candrow->{owntaskid} == $tid) {
                logm("$desc: already allocated to $tid");
                $ok=1; last;
            }
            if ($isshared) {
                logm("$desc: available, unsharing");
            } elsif ($isallocatable->($candrow)) {
                logm("$desc: allocating (was $candrow->{refkey})");
            } else {
                logm("$desc: locked by ".$findowner->($candrow));
                next;
            }
            $setres->($tid);
        } else {
            if ($isshared) {
                logm("$desc: unsharing, freeing");
            } elsif ($candrow->{owntaskid} != $tid) {
                logm("$desc: locked by ".$findowner->($candrow));
                next;
            } else {
                logm("$desc: freeing");
            }
            $setres->($magictask{idle});
        }

        if ($isshared) {
            $dbh_tests->do(<<END, {}, $restype,$resname);
		        DELETE FROM resource_sharing
			      WHERE restype = ? AND resname = ?
END
            $dbh_tests->do(<<END, {}, "share-$restype",$resname);
		        DELETE FROM resources
			      WHERE restype = ? AND resname = ?
END
        }
		
        $ok=1; last;
    }
    return $ok;
}

sub execute () {
    db_retry($dbh_tests, \@all_lock_tables, sub {

        alloc_prep();

        my $allok=1;
        foreach my $res (@ARGV) {
            my $ok= alloc_1res($res);
            if (!$ok) {
                logm("nothing available for $res, sorry");
                $allok=0;
            }
        }

        if (!$allok) {
            die "allocation/deallocation unsuccessful\n";
        }
    });
    logm("done.");
}

execute();
