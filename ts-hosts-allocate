#!/usr/bin/perl -w

use strict;
use DBI;
use Osstest;
use Data::Dumper;

readconfig();
opendb_state();

open DEBUG, ">/dev/null" or die $!;

while (@ARGV and $ARGV[0] =~ m/^-/) {
    $_= shift @ARGV;
    last if m/^--$/;
    while (m/^-./) {
        if (s/^-D/-/) {
            open DEBUG, ">&STDERR" or die $!;
        } else {
            die "$_ ?";
        }
    }
}

our @idents= @ARGV;

# initialised by setup:
our $taskid;
our $fi;
our %magictaskid;
our %provisional;
our %allocating;

our ($res1q, $claim_setres_q);

sub show_reskey {
    my (@reskey) = @_;
    return $reskey[2] eq '0' ? "@reskey[0..1]" : "@reskey";
}

sub alloc_one_hid ($) {
    my ($hid) = @_;
    # return values:
    #    1: some host allocated OK
    #    0: no hosts available, must defer

    my $hostsq= $dbh_tests->prepare(<<END);
        SELECT *
          FROM resources JOIN hostflags
            ON (restype='host' AND resname=hostname AND hostflag=?)
END

    my $flagscheckq= $dbh_tests->prepare(<<END);
        SELECT * FROM hostflags
         WHERE hostname = ? AND hostflag = ?
END

    my $recentflights_q= $dbh_tests->prepare(<<END);
            SELECT * FROM flights f
                     JOIN jobs j USING (flight)
                     JOIN runvars r
                             ON  f.flight=r.flight
                            AND  r.name='host'
                    WHERE  j.job=r.job
                      AND  f.blessing=?
                      AND  f.branch=?
                      AND  r.val=?
                 ORDER BY f.started desc
                    LIMIT 1
END

    my $shared_q= $dbh_tests->prepare(<<END);
            SELECT s.restype, s.resname, s.sharetype, s.state, s.wear,
                   ( SELECT count(*)
		       FROM resources r
	              WHERE r.restype=?
                        AND r.resname=?
                        AND r.owntaskid!=?
                        AND r.owntaskid!=?
                     ) AS ntasks
              FROM resource_sharing s
             WHERE s.restype=? AND s.resname=?
END

    my $sharing_slot_q= $dbh_tests->prepare(<<END);
            SELECT * FROM resources
	            WHERE restype=? AND resname=? AND owntaskid=?
		    LIMIT 1
END

    my $claim_share_reuse_q= $dbh_tests->prepare(<<END);
        UPDATE resource_sharing
           SET wear = wear + 1
         WHERE restype=? AND resname=?
END

    my $claim_rmshares_q= $dbh_tests->prepare(<<END);
        DELETE FROM resources
              WHERE restype=? AND resname=?
                AND (owntaskid=? OR owntaskid=?)
END
    my $claim_noshares_q= $dbh_tests->prepare(<<END);
        SELECT * FROM resources
              WHERE restype=? AND resname=?
              LIMIT 1
END
    my $claim_rmshare_q= $dbh_tests->prepare(<<END);
        DELETE FROM resource_sharing
              WHERE restype=? AND resname=?
END

    my $claim_share_new_q= $dbh_tests->prepare(<<END);
        INSERT INTO resource_sharing
                    (restype, resname, sharetype, state,  wear)
             VALUES (?,       ?,       ?,         'prep', 1   )
END
    my $claim_share_newresource_q= $dbh_tests->prepare(<<END);
        INSERT INTO resources
                    (restype, resname, shareix, owntaskid, subtask)
             VALUES (?,       ?,       ?,       ?,         ''     )
END

    my $use= $r{$hid->{Ident}};
    my $shr= $hid->{Shared};
    my $findhostsq;

    $res1q= $dbh_tests->prepare(<<END);
        SELECT *
          FROM resources
         WHERE restype=? AND resname=? AND shareix=?
END

    $claim_setres_q= $dbh_tests->prepare(<<END);
        UPDATE resources
           SET owntaskid = ?, subtask = ?
         WHERE restype=? AND resname=? AND shareix=?
END

    if (defined $use) {
        print DEBUG "HID $hid->{Ident} USE $use\n";
        $res1q->execute('host',$use,0);
        $findhostsq= $res1q;
    } else {
        print DEBUG "HID $hid->{Ident} INTENDED $fi->{intended}\n";
        $hostsq->execute("blessed-$fi->{intended}");
        $findhostsq= $hostsq;
    }
    my @candidates;
    my $any=0;

    my $cleanup= sub {
        $res1q->finish();
        $hostsq->finish();
    };

    while (my $candrow= $findhostsq->fetchrow_hashref()) {
        $candrow->{Warnings}= [ ];
        $candrow->{Host}= $candrow->{resname};

        my $dbg= "HID $hid->{Ident} HOST $candrow->{resname}";
        print DEBUG "$dbg\n";
        my @nogood;
        foreach my $flag (keys %{ $hid->{Flags} }) {
            print DEBUG "$dbg FLAG $flag\n";
            $flagscheckq->execute($candrow->{resname}, $flag);
            next if $flagscheckq->fetchrow_arrayref();
            push @nogood, $flag;
            $flagscheckq->finish();
        }
        print DEBUG "$dbg FLAGS NOGOOD: @nogood.\n";
        if (@nogood) {
            next unless defined $use;
            push @{ $candrow->{Warnings} },
                "specified host lacks flags @nogood";
        }
        $any++;

        my $reskey= "$candrow->{restype} $candrow->{resname} 0";

        print DEBUG "$dbg GOOD $candrow->{owntaskid} $reskey\n";

        my $allocatable= $candrow->{owntaskid} == $magictaskid{allocatable}
            || ($candrow->{owntaskid} == $taskid &&
                defined $provisional{$reskey} &&
                !defined $allocating{$reskey});

        print DEBUG "$dbg ALLOC PLAIN $allocatable\n";

        my $shared;
        if ($candrow->{owntaskid} == $magictaskid{shared}) {
            $candrow->{SharedResType}= 'share-'.$candrow->{restype};
            $shared_q->execute
                ($candrow->{SharedResType}, $candrow->{resname},
                 $magictaskid{allocatable}, $magictaskid{preparing},
                 $candrow->{restype}, $candrow->{resname});

            $shared= $shared_q->fetchrow_hashref();
            $shared_q->finish();

            die "$candrow->{resname} ?" unless $shared;
            $candrow->{Shared}= $shared;

            print DEBUG "$dbg ALLOC ISSHARED".
                " $shared->{sharetype} $shared->{state}".
                " $shared->{ntasks} $shared->{wear}\n";

            if (!$shared->{ntasks}) {
                print DEBUG "$dbg ALLOC ISSHARED CAN-UNSHARE\n";
                $allocatable= 1;
            }
        }

        if (defined $shr &&
            defined $shared &&
            $shared->{sharetype} eq $shr &&
            $shared->{wear} < $hid->{SharedMaxWear}) {
            print DEBUG "$dbg ALLOC SHARED ST".
                " $candrow->{SharedResType} $shared->{state}\n";

            if ($shared->{state} eq 'ready') {
                $sharing_slot_q->execute($candrow->{SharedResType},
                                         $shared->{resname},
                                         $magictaskid{allocatable});
                my $slot= $sharing_slot_q->fetchrow_hashref();
                $sharing_slot_q->finish();
                if (!$slot) {
                    # this is no use then
                    print DEBUG "$dbg ALLOC SHARED AVAIL BUSY\n";
                    next;
                } else {
                    print DEBUG "$dbg ALLOC SHARED AVAIL SLOTFREE".
                        " $slot->{shareix}\n";
                    $allocatable= 1;
                    $slot->{Host}= $candrow->{resname};
                    $slot->{BaseRow}= $candrow;
                    $slot->{Warnings}= $candrow->{Warnings};
                    $slot->{SharingReuse}= 1;
                    $slot->{Cost}= 0;
                    $candrow= $slot;
                }
            } else {
                if ($shared->{ntasks}) {
                    # someone else is preparing it, we must wait
                    # no point thinking any more
                    logm("host $candrow->{resname} shareable $shr".
                         " for $hid->{Ident} is being prepared".
                         " ($shared->{state}, $shared->{ntasks})");
                    $cleanup->();
                    return 0;
                }
                # someone was preparing it but they aren't any more
                push @{ $candrow->{Warnings} },
                "previous preparation apparently abandoned";
                $allocatable= 1;
                $candrow->{Cost}= 1;
            }
        } else {
            next unless $allocatable;
            $recentflights_q->execute($fi->{intended},
                                      $fi->{branch},
                                      $candrow->{hostname});
            my $recent= $recentflights_q->fetchrow_hashref();
            $recentflights_q->finish();
            $candrow->{Cost}=
                defined($recent) ? $recent->{started} : 1;
            print DEBUG "$dbg ALLOC PLAIN OK $candrow->{Cost}\n";
        }

        die unless $allocatable;
        push @candidates, $candrow;
    }

    print DEBUG "HID $hid->{Ident} CANDS ".scalar(@candidates)."\n";

    @candidates= sort { $a->{Cost} <=> $b->{Cost} } @candidates;
    if (!@candidates) {
        logm("none of $any hosts for $hid->{Ident} available");
        die "no possible hosts" unless $any;
        $cleanup->();
        return 0;
    }

    # Right, allocate this one!
    my $candrow= $candidates[0];
    my @reskey= map { $candrow->{$_} } qw(restype resname shareix);

    print DEBUG "HID $hid->{Ident} GO @reskey\n";

    if ($candrow->{SharingReuse}) {
        print DEBUG "HID $hid->{Ident} GO @reskey SHARING REUSE\n";
        $claim_share_reuse_q->execute($candrow->{BaseRow}{restype},
                                      $candrow->{resname});
        $claim_share_reuse_q->finish();
    } else {
        if ($candrow->{Shared}) {
            print DEBUG "HID $hid->{Ident} GO @reskey UNSHARE\n";
            $claim_rmshares_q->execute($candrow->{SharedResType},
                                       $candrow->{Shared}{resname},
                                       $magictaskid{allocatable},
                                       $magictaskid{preparing});
            $claim_rmshares_q->finish();
            $claim_noshares_q->execute($candrow->{SharedResType},
                                       $candrow->{Shared}{resname});
            my $bad= $claim_noshares_q->fetchrow_hashref();
            $claim_noshares_q->finish();
            die Dumper($bad).'?' if $bad;
            
            $claim_rmshare_q->execute($candrow->{restype},
                                      $candrow->{resname});
            $claim_rmshare_q->finish();
        }
        if ($shr) {
            print DEBUG "HID $hid->{Ident} GO @reskey SHARE\n";
            $claim_setres_q->execute($magictaskid{shared},"", @reskey);
            $claim_setres_q->finish();
            $claim_share_new_q->execute($candrow->{restype},
                                        $candrow->{resname},
                                        $shr);
            $claim_share_new_q->finish();
            my $shrestype= 'share-'.$candrow->{restype};
            for (my $ix=1; $ix<=$hid->{SharedMaxTasks}; $ix++) {
                $claim_share_newresource_q->execute
                    ($shrestype, $candrow->{resname}, $ix,
                     ($ix==1 ? $magictaskid{allocatable}
                      : $magictaskid{preparing}));
                $claim_share_newresource_q->finish();
            }
            $reskey[0]= $shrestype;
            $reskey[2]= 1;
        }
    }
    
    logm("allocating for $hid->{Ident} (from $any): ".show_reskey(@reskey));
    foreach my $warn (@{ $candrow->{Warnings} }) {
        logm("warning about ".show_reskey(@reskey).": $warn");
    }

    print DEBUG "HID $hid->{Ident} GO @reskey ALLOCATE\n";
    my $allocd= $claim_setres_q->execute
        ($taskid, "$flight.$job $hid->{Ident}", @reskey);
    die unless $allocd;
    $claim_setres_q->finish();

    $candrow->{ResKey}= \@reskey;
    $hid->{AllocInfo}= $candrow;
    $hid->{Allocated}= $candrow->{Host};

    $allocating{"@reskey"}= 1;
    print DEBUG "HID ALLOCATING BASE @reskey\n";
    my $sharebase= $hid->{BaseRow};
    if ($sharebase) {
        my $sharekey= join ' ', map { $sharebase->{$_} }
                        qw(restype resname resix);
        print DEBUG "HID ALLOCATING SHARE $sharekey\n";
        $allocating{$sharekey}= 1;
    }
    # This is actually purely to stop us using provisionally-allocated
    # resources more than once: normally, resources which are
    # allocated to us already aren't considered available to us unless
    # they are in %provisionals.  If they are in there then we may
    # allocate them "from ourself".  But that means we could allocate
    # the same resource for two different purposes, so this catches
    # that corner case.

    if (!$candrow->{Shared}) {
        # 
        # this stops us reusing
    }

    $cleanup->();
    return 1;
}

sub setup () {
    $taskid= findtask();

    $fi= $dbh_tests->selectrow_hashref(<<END, {}, $flight);
        SELECT * FROM flights
         WHERE flight = ?
END

    foreach my $rk (qw(allocatable shared preparing idle)) {
        $magictaskid{$rk}= $dbh_tests->selectrow_array(<<END, {}, $rk);
            SELECT taskid FROM tasks
             WHERE type='magic' AND refkey=?
END
    }
}

sub new_provisionals {
    our (@hids) = @_;
    my @provs;
    
    foreach my $hid (@hids) {
        print DEBUG "PROV-NEW HID $hid->{Ident}\n";

        my $candrow= $hid->{AllocInfo};
        next unless $candrow;
        print DEBUG "PROV-NEW HID $hid->{Ident} CAND $candrow->{resname}\n";

        next if $hid->{Shared};

        my (@reskey)= ($candrow->{restype},
                       $candrow->{resname},
                       $candrow->{shareix});
        $hid->{ProvResKey}= \@reskey;
        print DEBUG "PROV-NEW HID $hid->{Ident} NO-SHARE @reskey\n";

        next if defined $provisional{"@reskey"};
        print DEBUG "PROV-NEW HID $hid->{Ident} NEW-PROV\n";

        push @provs, $hid;
    }
    return @provs;
}

sub grab_more_provisionals {
    our (@hids) = @_;

    foreach my $hid (@hids) {
        my $reskey= $hid->{ProvResKey};
        print DEBUG "PROV-MORE HID $hid->{Ident} @$reskey\n";

        $res1q->execute(@$reskey);
        my $was= $res1q->fetchrow_hashref();
        $res1q->finish();
        print DEBUG "PROV-MORE HID $hid->{Ident} WAS $was->{owntaskid}\n";

        next unless $was->{owntaskid} == $magictaskid{allocatable};
        print DEBUG "PROV-MORE HID $hid->{Ident} WAS ALLOCATABLE\n";
        
        $claim_setres_q->execute($taskid, "$flight.$job (prov.)", @$reskey);
        $claim_setres_q->finish();
        $provisional{"@$reskey"}= 1;

        logm("provisionally allocated: $hid->{Ident} ".show_reskey(@$reskey));
    }
    print DEBUG "PROV-MORE DONE\n";
}

sub free_provisionals_all_except {
    our (@keephids) = @_;
    foreach my $hid (@keephids) {
        next unless $hid->{AllocInfo};
        my $reskey= "@{ $hid->{AllocInfo}{ResKey} }";
        print DEBUG "PROV CLEANING $reskey\n";
        delete $provisional{$reskey};
    }
    foreach my $reskey (sort keys %provisional) {
        my (@reskey) = split / /, $reskey;
        logm("cancelling provisional allocation ".show_reskey(@reskey));
        $res1q->execute(@reskey);
        my $was= $res1q->fetchrow_hashref();
        $res1q->finish();
        print DEBUG "PROV CLEANING @reskey WAS $was->{owntaskid}\n";
        die "@reskey $was->{owntaskid}" unless $was->{owntaskid} == $taskid;
        $claim_setres_q->execute($magictaskid{idle}, "", @reskey);
        $claim_setres_q->finish();
    }
    print DEBUG "PROV CLEANED.\n";
}

sub alloc_hosts () {
    my @hids;
    my %allflags;

    # greedy allocator, but we sort by flags wanted so
    # at least we don't do things obviously stupidly
    foreach my $ident (@idents) {
        my @flags= get_hostflags($ident);
        print DEBUG "HID $ident FLAGS @flags\n";
        my $hid= { Ident => $ident };
        my %flags;
        foreach my $flag (@flags) {
            print DEBUG "HID $ident FLAG $flag\n";
            if ($flag =~ m/^share-/) {
                die if exists $hid->{Shared};
                my $shr= $';
                $hid->{Shared}= $shr;
                if ($shr =~ m/^build-/) {
                    $hid->{SharedMaxTasks}= 3;
                    $hid->{SharedMaxWear}= 10;
                } else {
                    # who can say
                    $hid->{SharedMaxTasks}= 2;
                    $hid->{SharedMaxWear}= 5;
                }
                print DEBUG "HID $ident FLAG $flag SHARE $shr".
                    " $hid->{SharedMaxTasks} $hid->{SharedMaxWear}\n";
                next;
            }
            $flags{$flag}= $allflags{$flag}= 1;
        }
        $hid->{Flags}= \%flags;
        print DEBUG "HID $ident FLAGS ".(join ',', sort keys %flags)."\n";
        push @hids, $hid;
    }

    my $flagscountq= $dbh_tests->prepare(<<END);
        SELECT count(*)
          FROM hostflags
         WHERE hostflag = ?
END
    foreach my $f (keys %allflags) {
        $flagscountq->execute($f);
        my $row= $flagscountq->fetchrow_arrayref();
        $flagscountq->finish();
        die unless defined $row;
        print DEBUG "FLAG $f $row->[0]\n";
        $allflags{$f}= $row->[0];
    }
    my @allflags = sort { $allflags{$a} <=> $allflags{$b} } keys %allflags;

    print DEBUG "FLAGS ALL @allflags\n";

    foreach my $hid (@hids) {
        $hid->{Priority}= join '', map {
            exists($hid->{Flags}{$_}) ? '1' : '0'
            } @allflags;
        print DEBUG "HID $hid->{Ident} PRIORITY $hid->{Priority}\n";
    }
    @hids= sort { $b->{Priority} cmp $a->{Priority} } @hids;

    my $finalok= 0;
    while (!$finalok) {
        alloc_resources(WaitStartAdjust => (@idents * -10),
                        WaitStart => $fi->{started},
                        sub {

            logm("allocating hosts: ".join(' ', map { $_->{Ident} } @hids));

            undef %allocating;
            foreach my $hid (@hids) {
                delete $hid->{AllocInfo};
                delete $hid->{Allocated};
                delete $hid->{ProvResKey};
            }

            my $allok= 1;
            foreach my $hid (@hids) {
                $allok= 0 unless
                    alloc_one_hid($hid);
            }

            # Now @hids contains a proposed, perhaps partial, allocation

            if ($allok) {
                print DEBUG "YES YES YES\n";
                free_provisionals_all_except(@hids);
                $finalok= 1;
                return 1;
            }

            print DEBUG "HARRMFH\n";

            # Does this proposed allocation contain any hosts which we
            # don't have already provisionally allocated, and which
            # we would like to provisionally allocate ?
            my @newprovs= new_provisionals(@hids);

            print DEBUG "HARRMFH ".scalar(@newprovs)."\n";

            return 0 unless @newprovs; # keep what we have, and wait

            logm("host allocation: need to wait, rolling back");

            alloc_resources_rollback_begin_work();
            free_provisionals_all_except(@hids);
            grab_more_provisionals(@newprovs);

            return 2;
        });
    }

    foreach my $hid (@hids) {
        my $hn= $hid->{Allocated};;
        die $hid->{Ident} unless defined $hn;
            
        store_runvar($hid->{Ident}, $hn);
    }
}

setup();
alloc_hosts();
