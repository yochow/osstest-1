#!/usr/bin/perl -w
# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict qw(vars);
use DBI;
use Osstest;
use Osstest::Debian;
use Osstest::TestSupport;

tsreadconfig();

our $stage=0;
if (@ARGV && $ARGV[0] =~ m/^--stage(\d+)$/) { $stage=$1; shift @ARGV; }

defined($r{bios}) or die "Need to define which bios to use";

# Libvirt doesn't know anything about bios. It will always use the
# default one (seabios). Stub out rombios and ovmf to avoid false
# positive results.
if ($r{bios} =~ m/ovmf|rombios/ && $r{toolstack} eq 'libvirt') {
    die "libvirt + $r{bios} is not supported yet.";
}

our ($whhost,$gn) = @ARGV;
$whhost ||= 'host';
$gn ||= 'debianhvm';

our $ho= selecthost($whhost);

# guest memory size will be set based on host free memory, see below
our $ram_mb;
our $disk_mb= 10000;

our $guesthost= "$gn.guest.osstest";
our $gho;

our ($kernel, $ramdisk);

our $gsuite;

sub preseed () {

    my $preseed_file = preseed_base($gho,$gsuite,'','',());

    $preseed_file .= (<<END);
d-i netcfg/get_hostname string $gn

d-i partman-auto/disk string /dev/xvda
d-i partman-auto/method string  regular

d-i partman-auto/expert_recipe string \\
        boot-root :: \\
                512 50 512 vfat \\
                        \$primary{ } \$bootable{ } \\
                        method{ efi } format{ } \\
                        use_filesystem{ } filesystem{ vfat } \\
                        mountpoint{ /boot/efi } \\
                . \\
                5000 50 5000 ext4 \\
                        method{ format } format{ } \\
                        use_filesystem{ } filesystem{ ext4 } \\
                        mountpoint{ / } \\
                . \\
                512 30 100% linux-swap \\
                        method{ swap } format{ } \\
                .

d-i apt-setup/cdrom/set-first boolean false
END


    # Our OVMF does not have a persistent variable store and therefore
    # cannot remember the boot entry added by the Debian
    # installer. Therefore we ensure that a copy of the bootloader is
    # copied to the removable media path, which is the EFI fallback.
    #
    # From Jessie onwards this can be worked around by using the fix to
    # #767037 i.e. preseeding grub-installer/force-efi-extra-removable.
preseed_hook_command($gho, 'late_command', '', <<END) if $gsuite =~ /wheezy/;
#!/bin/sh
set -ex

b=/target/boot/efi/EFI
if [ -e \$b/debian/grubx64.efi ] ; then
    mkdir -p \$b/boot
    cp \$b/debian/grubx64.efi \$b/boot/bootx64.efi
fi
END

    $preseed_file .= preseed_hook_cmds();

    return $preseed_file;
}

sub gcmdline (;$) {
    my ($extra) = @_;
    my @dicmdline = ();
    my $gconsole = "console=ttyS0,115200n8";

    push @dicmdline, $gconsole;
    push @dicmdline, di_installcmdline_core($gho, '/preseed.cfg',
					    PreseedScheme => 'file');
    push @dicmdline, $extra if $extra;

    push @dicmdline, "--";
    # See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=762007 for
    # why console= is repeated.
    push @dicmdline, $gconsole;

    return join(" ", @dicmdline);
}

sub grub_cfg () {
    my $cmdline = gcmdline();

    return <<"END";
set default="0"
set timeout=5

menuentry 'debian guest auto Install' {
    linux $kernel $cmdline
    initrd $ramdisk
}
END
}

sub isolinux_cfg () {
    my $cmdline = gcmdline("initrd=$ramdisk");

    return <<"END";
    default autoinstall
    prompt 0
    timeout 0

    label autoinstall
        kernel $kernel
        append $cmdline
END
}

sub prepare_initrd ($$$) {
    my ($initrddir,$newiso,$preseed_file_path) = @_;
    return <<"END";
      rm -rf $initrddir
      mkdir $initrddir
      cd $initrddir
      gzip -d < $newiso$ramdisk | cpio --extract --make-directories --no-absolute-filename
      cp $preseed_file_path preseed.cfg
      find . | cpio -H newc --create | gzip -9 > $newiso$ramdisk
      cd -
      rm -rf $initrddir
      cd $newiso
      find -L -type f -print0 | xargs -0 md5sum > md5sum.txt
      cd -
END
}

our $emptyiso= "/root/$flight.$job.$gn-empty.iso";

sub iso_path ($$) {
    my ($which, $deftail) = @_;
    my $v = guest_var($gho, "iso_$which", "/install.amd/$deftail");
    die "$gho->{Guest} $which $v ?" unless $v =~ m#^/#;
    return $v;
}

sub prep () {
    target_install_packages_norec($ho, qw(lvm2 rsync genisoimage));

    my $isotimeout= 600;

    $gho= prepareguest($ho, $gn, $guesthost, 22,
                       $disk_mb + 1,
                       200);

    $gsuite = guest_var($gho,'suite',$c{GuestDebianSuite});
    $kernel = iso_path('kernel', 'vmlinuz');
    $ramdisk = iso_path('ramdisk', 'initrd.gz');

    my $base = "/root/$flight.$job.$gn-";
    my $newiso= $base . "newiso";
    my $emptydir= $base . "empty-dir";
    my $initrddir= $base . "initrd-dir";
    my $preseed_file_path = $base . "preseed";

    my @isogen_extra = qw(-eltorito-alt-boot
                          -no-emul-boot
                          -r);

    iso_create_empty($ho, $emptyiso, $emptydir);

    # If host has >8G free memory, create a guest with 4G memory to catch
    # any error that triggers cross 4G boundary
    my $host_freemem_mb = host_get_free_memory($ho);
    my $ram_minslop = 100;
    my $ram_lots = 5000;
    if ($host_freemem_mb > $ram_lots * 2 + $ram_minslop) {
        $ram_mb = $ram_lots;
    } else {
        $ram_mb = 768;
    }
    logm("Host has $host_freemem_mb MB free memory, setting guest memory size to $ram_mb MB");

    more_prepareguest_hvm($ho,$gho, $ram_mb, $disk_mb,
                          OnReboot => 'preserve',
                          Bios => $r{bios},
                          PostImageHook => sub {
        my $cmds = iso_copy_content_from_image($gho, $newiso);
        target_cmd_root($ho, $cmds, $isotimeout);

        my $bootfile = 'boot/grub/efi.img';
        if (!target_file_exists($ho, "$newiso/$bootfile")) {
            $bootfile = "isolinux/isolinux.bin";
            push @isogen_extra, qw(-c isolinux/boot.cat);
        }
        logm("using boot image $bootfile");
        push @isogen_extra, '-b', $bootfile;

        my @isogen_opts = (iso_gen_flags_basic(), @isogen_extra);

        target_putfilecontents_root_stash($ho, 10, preseed(),
                                          $preseed_file_path);

        $cmds = prepare_initrd($initrddir,$newiso,$preseed_file_path);
        target_cmd_root($ho, $cmds, $isotimeout);

        target_putfilecontents_root_stash($ho, 10, grub_cfg(),
                                          "$newiso/debian/boot/grub/grub.cfg")
	    if $bootfile =~ m/grub/;

        target_putfilecontents_root_stash($ho, 10, isolinux_cfg(),
                                          "$newiso/isolinux/isolinux.cfg");

        iso_create_genisoimage($ho, $gho->{Rimage}, $newiso, $isotimeout, @isogen_opts);
    });
}

if (!$stage) {
    prep();
    guest_create($gho);
} else {
    $gho= selectguest($gn,$gho);
}
if ($stage<2) {
    guest_await_reboot($ho,$gho,2000);
    guest_destroy($gho);
}

guest_editconfig_nocd($gho,$emptyiso);
guest_create($gho);
guest_await_dhcp_tcp($gho,300);
guest_check_up($gho);
