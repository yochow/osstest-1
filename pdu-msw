#!/usr/bin/perl -w

# This is part of "osstest", an automated testing framework for Xen.
# Copyright (C) 2009-2013 Citrix Inc.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


my $usagemsg= <<END;
usage:
  pdu-msw SWITCH-DNS-NAME PORT-NAME-REGEXP|PORT [[delayed-]on|off|0|1|reboot]
END

use strict qw(refs vars);
use Net::SNMP;
use Data::Dumper;

my $community= 'private';
my $baseoid= '.1.3.6.1.4.1.318.1.1.4.4.2.1';
my $baseoid_write= "$baseoid.3";

if (@ARGV<2 || @ARGV>3 || $ARGV[0] =~ m/^-/) { die "bad usage\n$usagemsg"; }

our ($dnsname,$outlet,$action) = @ARGV;

my ($session,$error) = Net::SNMP->session(
                                          -hostname => $dnsname,
                                          -community => $community,
                                          );
die "SNMP error $error " unless defined $session;

sub getname ($) {
    my ($port) = @_;
    my $oid= "$baseoid.4.$port";
    my $res= $session->get_request($oid);
    if ($res) {
        my $name= $res->{$oid};
        die unless defined $name;
        return $name;
    } elsif ($port>1 && $session->error_status() == 2) {
        return undef;
    } else {
        die "SNMP error on $oid ".$session->error()." ";
    }
}

my $useport;
my $usename;
if ($outlet =~ m/^\d+$/) {
    $useport= $outlet;
    $usename= getname($outlet);
    $usename= '?' unless defined $usename;
} else {
    my (@found,@all);
    my $ix=1;
    for (;; $ix++) {
        my $name= getname($ix);
        last unless defined $name;
        my $match= !!($name =~ m/$outlet/o);
        my $t= [ $ix, $name, $match ];
        push @all, $t;
        push @found, $t if $match;
        next;
    }
    if (@found!=1) {
        foreach my $t (@all) {
            printf("%1s %2d %s\n",
                   ($t->[2] ? '*' : ''),
                   $t->[0], $t->[1]);
        }
        die @found ? "multiple ports match\n" : "no ports match\n";
    }
    ($useport,$usename)= @{ $found[0] };
}

my $read_oid= "$baseoid.3.$useport";
my $write_oid= "$baseoid_write.$useport";

my @map= (undef, qw(
                    on
                    off
                    reboot
                    delayed-on
                    delayed-off
                    delayed-reboot));

sub show () {
    my $got= $session->get_request($read_oid);
    die "SNMP error reading $read_oid ".$session->error()." " unless $got;
    my $val= $got->{$read_oid};
    die unless $val;
    my $mean= $map[$val];
    die "$val ?" unless defined $mean;
    printf "#%s \"%s\" = %s\n", $useport, $usename, $mean;
}

sub set () {
    my $delayadd= ($action =~ s/^delayed-// ? 3 : 0);
    my $valset= ($action =~ m/^(?:0|off)$/ ? 2 :
                 $action =~ m/^(?:1|on)$/ ? 1 :
                 $action =~ m/^(?:reboot)$/ ? 3 :
                 die "unknown action $action\n$usagemsg");
        
    my $res= $session->set_request(-varbindlist => [ $write_oid, INTEGER, $valset ]);
    die "SNMP set ".$session->error()." " unless $res;
}

if (!defined $action) {
    show();
} else {
    print "was: "; show();
    set();
    print "now: "; show();
}
